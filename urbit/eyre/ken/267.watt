~%    %watt.267
    ~ 
  (%ut ut, %go go, %to to)
&.
::
  ::  Tier 1, atomic arithmetic
::
++  add
  ~.  %add
  |=  [a=@ b=@] 
  ^-  @
  ?:  .=(0 a)
    b
  $(a (dec a), b .+(b))
::
++  bex
  ~.  %bex
  |=  [a=@]
  ^-  @
  ?:  .=(0 a)
    1
  (mul 2 $(a (dec a)))
::
++  dec
  ~.  %dec
  |=  a=@
  ^-  @
  ~|  %dec
  ?<  .=(0 a)
  =+  b=@
  |-
  ?:  .=(a .+(b))
    b
  $(b .+(b))
::
++  div
  ~.  %div
  |=  [a=@ b=@]
  ^-  @
  ~|  %div
  ?<  .=(0 b)
  =+  c=@
  |-
  ?:  (lth a b)
    c
  $(a (sub a b), c .+(c))
::
++  gte
  ~.  %gte
  |=  [a=@ b=@]
  ^-  ?
  !(lth a b)
::
++  gth
  ~.  %gth
  |=  [a=@ b=@]
  ^-  ?
  !(lte a b)
::
++  lte
  ~.  %lte
  |=  [a=@ b=@]
  ?|(.=(a b) (lth a b))
::
++  lth
  ~.  %lth
  |=  [a=@ b=@]
  ^-  ?
  ?&
    !.=(a b)
    |-  ?:  .=(0 a)
          &
        ?:  .=(0 b)
          |
        $(a (dec a), b (dec b))
  --
::
++  max
  ~.  %max
  |=  [a=@ b=@]
  ^-  @
  ?:  (gth a b)
    a
  b
::
++  min
  ~.  %min
  |=  [a=@ b=@]
  ^-  @
  ?:  (lth a b)
    a
  b
::
++  mod
  ~.  %mod
  |=  [a=@ b=@]
  ^-  @
  ?<  .=(0 b)
  (sub a (mul b (div a b)))
::
++  mul
  ~.  %mul
  |=  [a=@ b=@]
  ^-  @
  =+  c=^-(@ 0)
  |-
  ?:  .=(0 a)
    c
  $(a (dec a), c (add b c))
::
++  nop
  |*  a=*
  a
::
++  sub
  ~.  %sub
  |=  [a=@ b=@]
  ^-  @
  ?:  .=(0 b)
    a
  $(a (dec a), b (dec b))
::
  ::  Tier 2, lists and units
::
++  bind
  ~.  %bind 
  |*  [a=*(unit) b=<*>]
  ?~  a
    ~
  [~ u=(b u.a)]
::
++  clap
  ~.  %clap
  |*  [a=*(unit) b=*(unit) c=|=(^ -<-)]
  ?~  a
    b
  ?~  b
    a
  [~ u=(c u.a u.b)]
::
++  drop
  ~.  %drop
  |*  a=*(unit)
  ?~  a
    ~
  [i=u.a t=~]
::
++  flop
  ~.  %flop
  |*  a=*(list)
  ^-  a
  =+  b=`a`~
  |-
  ?~  a
    b
  $(a t.a, b [i.a b])
::
++  lent
  ~.  %lent
  |=  a=*(list)
  ^-  @
  =+  b=@
  |-
  ?~(a b $(a t.a, b .+(b)))
::
++  levy
  ~.  %levy
  |*  [a=*(list) b=|=(p=* .?(p))]
  |-
  ^-  ?
  ?~  a
    &
  ?:  (b i.a)
    $(a t.a)
  |
::
++  lien
  ~.  %lien
  |*  [a=*(list) b=|=(p=* .?(p))]
  |-
  ^-  ?
  ?~  a
    |
  ?:  (b i.a)
    &
  $(a t.a)
::
++  list
  |*  a=<*>
  |=  b=*
  ?-    b
      ~           ~
      [i=* t=*]   [i=(a i.b) t=$(b t.b)]
  --
::
++  mate
  |*  [a=*(unit) b=*(unit)]
  ?~  a
    b
  ?~  b
    a
  ?.(.=(u.a u.b) ~|('mate' !!) a)
::
++  need
  ~.  %need
  |*  a=*(unit)
  ?~  a
    !!
  u.a
::
++  reel
  ~.  %reel
  |*  [a=*(list) b==+([p=* q=*] |.(q))]
  |-
  ^-  q.b
  ?~  a
    q.b
  (b i.a $(a t.a))
::
++  roll
  ~.  %roll
  |*  [a=*(list) b==+([p=* q=*] |.(q))]
  |-
  ^-  q.b
  ?~  a
    q.b
  $(a t.a, b b(q (b i.a q.b)))
::
++  skim
  ~.  %skim
  |*  [a=*(list) b=|=(p=* .?(p))]
  |-
  ^-  a
  ?~  a
    ~
  ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::
++  skip
  ~.  %skip
  |*  [a=*(list) b=|=(p=* .?(p))]
  |-
  ^-  a
  ?~  a
    ~
  ?:((b i.a) $(a t.a) [i.a $(a t.a)])
::
++  snag
  ~.  %snag
  |*  [a=@ b=*(list)]
  |-
  ?~  b
    !!
  ^-  i.b
  ?:  .=(0 a)
    i.b
  $(b t.b, a (dec a))
::
++  sort
  ~.  %sort
  |*  [a=*(list) b=|=([p=* q=*] .=(p q))]
  |-
  ^-  a
  ?~  a
    ~
  %+  weld
    $(a (skim a.$ |=(c=i.a (b c i.a))))
  `a.$`[i.a $(a (skim a.$ |=(c=i.a (b i.a c))))]
::
++  tree
  |*  a=<*>
  |=  b=*
  ?-    b
      ~               ~
      [n=* l=* r=*]   [n=(a n.b) l=$(b l.b) r=$(b r.b)]
  --
::
++  turn
  ~.  %turn
  |*  [a=*(list) b=<*>]
  |-
  ?~  a
    ~
  [i=(b i.a) t=$(a t.a)]
::
++  unit
  |*  a=<*>
  |=  b=*
  ?-    b
      ~       ~
      [~ *]   [~ u=(a +.b)]
  --
::
++  weld
  ~.  %weld
  |*  [a=*(list) b=*(list)]
  |-
  ^-  b
  ?~  a
    b
  [i.a $(a t.a)]
::
  ::  Tier 3, noun surgery
::
++  axis  <@>
++  bloq  <@>
++  cap
  ~.  %cap
  |=  [a=*axis]
  ^-  *<2 3>
  ?-    a
      2       2
      3       3
      *<0 1>  !!
      *       $(a (div a 2))
  --
::  
++  cat
  ~.  %cat
  |=  [a=*bloq b=@ c=@]
  (add (lsh a (met a b) c) b)
::
++  con
  ~.  %con
  |=  [a=@ b=@]
  =+  [c=`@`0 d=`@`0]
  |-
  ?:  ?&(.=(0 a) .=(0 b))
    d
  %=  $
    a   (rsh 0 1 a)
    b   (rsh 0 1 b)
    c   .+(c)
    d   (add d (lsh 0 c ?&(.=(0 (end 0 1 a)) .=(0 (end 0 1 b)))))
  --
::
++  cut
  ~.  %cut
  |=  [a=*bloq [b=@ c=@] d=@]
  (end a c (rsh a b d))
::
++  dis
  ~.  %dis
  |=  [a=@ b=@]
  =+  [c=@ d=@]
  |-
  ?:  ?|(.=(0 a) .=(0 b))
    d
  %=  $
    a   (rsh 0 1 a)
    b   (rsh 0 1 b)
    c   .+(c)
    d   (add d (lsh 0 c ?|(.=(0 (end 0 1 a)) .=(0 (end 0 1 b)))))
  --
::
++  dor
  ~.  %dor
  |=  [a=* b=*]
  ^-  ?
  ?:  .=(a b)
    &
  ?.  ?=(@ a)
    ?.  ?=(@ b)
      ?:  .=(-.a -.b)
        $(a +.a, b +.b)
      $(a -.a, b -.a)
    |
  ?.  ?=(@ b)
    &
  (lth a b)
::
++  end
  ~.  %end
  |=  [a=*bloq b=@ c=@]
  (mod c (bex (mul (bex a) b)))
::
++  gor
  ~.  %gor
  |=  [a=* b=*]
  ^-  ?
  =+  [c=(mug a) d=(mug b)]
  ?:  .=(c d)
    (dor a b)
  (lth c d)
::
++  hor
  ~.  %hor
  |=  [a=* b=*]
  ^-  ?
  ?:  ?=(@ a)
    ?:  ?=(@ b)
      (gor a b) 
    &
  ?:  ?=(@ b)
    |
  ?:  .=(-.a -.b)
    (gor +.a +.b)
  (gor -.a -.b)
::
++  lsh
  ~.  %lsh
  |=  [a=*bloq b=@ c=@]
  (mul (bex (mul (bex a) b)) c)
::
++  mix
  ~.  %mix
  |=  [a=@ b=@]
  ^-  @
  =+  [c=`@`0 d=`@`0]
  |-
  ?:  ?&(.=(0 a) .=(0 b))
    d
  %=  $
    a   (rsh 0 1 a)
    b   (rsh 0 1 b)
    c   .+(c)
    d   (add d (lsh 0 c .=((end 0 1 a) (end 0 1 b))))
  --
::
++  met
  ~.  %met
  |=  [a=*bloq b=@]
  ^-  @
  =+  c=`@`0
  |-
  ?:  .=(0 b)
    c
  $(b (rsh a 1 b), c .+(c))
::
++  mas
  ~.  %mas
  |=  [a=*axis]
  ^-  *axis
  ?-  a
    1   !!
    2   1
    3   1
    *   (add (mod a 2) (mul $(a (div a 2)) 2))
  --
::
++  mug
  ~.  %mug
  |=  a=*
  ^-  @
  &-  ?.  ?=(@ a)
        =+  [b=$(a -.a) c=$(a +.a)]
        =+  d=(mix b (add (end 5 1 (lsh 3 1 c)) (rsh 3 3 c)))
        |-
        =+  e=(dis 0x7fffffff (chum d))
        ?:  .=(0 e)
          $(d .+(d))
        e
      =+  b=`@`0x18d0a625
      |-
      =+  c=(met 5 a)
      =+  d=`@`0
      =+  e=b
      |-
      ?:  .=(d c)
        =+  f=(dis 0x7fffffff e)
        ?:  .=(0 f)
          $$(b .+(b))
        f
      $(d .+(d), e (chum (mix e (cut 5 [d 1] a))))
  ::
  ++  chum
    |=  [b=@]
    =-  (end 5 1 c)
    ^=  c
    (dice 3 (dice 2 (dice 1 (dice 0 b))))
  ::
  ++  dice
    |=  [b=@ c=@]
    (mix c (sbox (cut 3 [b 1] c))) 
  ::
  ++  sbox
    |=  [b=@]
    =-  (cut 5 [b 1] c)
    ^=  c
    0x45bd2fb7\ /eec357b8\ /2ae29f22\ /bb412e03\ /08445336\ /52ca46d8\
     /76d680b9\ /b9e06f14\ /6f8b9c36\ /a53ef834\ /e3533b5b\ /c5cd423e\
     /0cfd4d14\ /12924b1a\ /3e77ee18\ /1804e2a5\ /75d9c4e1\ /6d4b9a3e\
     /5d56c751\ /12ad4163\ /b9df9e63\ /fbfbdac7\ /54464f51\ /4b72be7f\
     /180d4405\ /1b456773\ /5fb51d73\ /2d4774c2\ /381585e2\ /0209e49e\
     /52c0256a\ /6deac45d\ /3f55045c\ /40b92e52\ /5242aa7a\ /a47337b1\
     /bc816aba\ /4bbb0ecf\ /f82cb4ad\ /0bc99c47\ /78a5c74c\ /9182f20d\
     /7b941dc3\ /ff307dd2\ /fc36ca9d\ /0c32efad\ /b1c38ca7\ /b799e1be\
     /fd0dbfee\ /9887957d\ /70186f9e\ /31325eca\ /48f0ac44\ /c7eb6480\
     /ab1f9401\ /167cf21d\ /dce5b8fa\ /121c9f64\ /e95eacb5\ /c50dca03\
     /8b29fd75\ /875f1bb9\ /261c8938\ /3bf794dc\ /e4395998\ /1b06df20\
     /19c11553\ /eefbdb16\ /54447c57\ /f54a4761\ /bdf13b8c\ /88502921\
     /72553aee\ /c63a1157\ /03a1f284\ /f5b59c3c\ /96923c87\ /e2c0936d\
     /4f112d16\ /0f4c5845\ /1055a07d\ /d82afef8\ /72fb1b49\ /0fa54e14\
     /637d01f5\ /7fe89a8b\ /0617eda8\ /4354f3e7\ /712f6316\ /9036b901\
     /111a1094\ /70c78bcc\ /28329ab3\ /fdf004ca\ /2026a870\ /85ac98d2\
     /3f52439e\ /e030c8ed\ /a7589924\ /05af69ed\ /566dd09c\ /4237062e\
     /e9fc60eb\ /c415321c\ /ac4fc47f\ /b265b0ee\ /95cdc493\ /3beb6b4d\
     /e777884a\ /370f9e65\ /6a52c674\ /62dc97c6\ /e5d5238e\ /b6315b6a\
     /c845a9e2\ /026c78ab\ /13beec00\ /b3ed287a\ /a01ebf2b\ /b5c0da93\
     /deeedce8\ /3e5ec58d\ /e83350f0\ /e6ffe2fb\ /a3765510\ /37f42e48\
     /474c90cf\ /78eea53d\ /d10faca2\ /a9417956\ /7c600063\ /14187d04\
     /faffdd23\ /44844992\ /61f4a52d\ /a234566b\ /a46b9dd7\ /1a9d0bd3\
     /cf3e4033\ /b3bcada3\ /00f3ef4e\ /7367a5f9\ /5e24070c\ /1b973827\
     /5dcd3652\ /95b1eb1f\ /035857a4\ /c090c33b\ /5eba8280\ /475d8534\
     /7fb44be7\ /3bffc889\ /dbaf1fa2\ /948328b1\ /56a8a01c\ /6717fa39\
     /4c41d2c6\ /b3275702\ /51634e92\ /51a573dd\ /d3ea1b9d\ /be74ea0b\
     /9093fa5f\ /d2e1d0d1\ /8a1fd93a\ /8f1d0a6e\ /b7a9e735\ /deb0aa12\
     /48d76271\ /e808ec02\ /8e498a90\ /83539726\ /86c7973e\ /44337e55\
     /81f4f7ca\ /3052b642\ /873b540e\ /68d8efa2\ /18494012\ /decc1486\
     /29079afa\ /b81a7b1d\ /63dd42a0\ /3cab1b6f\ /713fffa2\ /08835b42\
     /6dd6f5f8\ /65a14a04\ /5eab8eac\ /2fe5b7f9\ /bbc96404\ /f593e52b\
     /b2078d1a\ /f192cbcd\ /c5e102b2\ /9187837c\ /bddd8a18\ /5caf8a56\
     /3b7aa391\ /88fd1802\ /1e458e1d\ /5f606388\ /513ce98d\ /aed1093b\
     /ae87124c\ /f537ea14\ /0f4bb673\ /cfbeae41\ /123e5e9f\ /e14077a2\
     /40acd8dc\ /103b81cf\ /683fa466\ /9b9e2cec\ /23171ec6\ /2ba16060\
     /d3bfabae\ /dd68fcd2\ /f60ee7be\ /f44c697e\ /7990bd4e\ /3ce83919\
     /bc457a9d\ /5022a039\ /a158b454\ /80722ba6\ /87652d85\ /e2ddee5a\
     /5c43205e\ /c62f6816\ /4c680e34\ /151f4b17\ /9570fa83\ /eb9f040e\
     /22b9bd9c\ /d156e14b\ /3a30bdd8\ /f00fc9e2\ /62bcfdef\ /da4952df\
     /0c100eda\ /ccffce0a\ /1994625d\ /b0cd88c6\ /766ff6ec\ /7c8f831a\
     /7824fff6\ /dee5b579\ /99267e88\ /f8820121\ /6220ecc5\ /f40f7a8d\
     /fe8c511a\ /a9afcd63\ /ba9cd382\ /352598d8
  ==
::
++  peg
  ~.  %peg
  |=  [a=*axis b=*axis]
  ^-  *axis
  ?-  b
    1   a
    2   (mul a 2)
    3   .+((mul a 2))
    *   (add (mod b 2) (mul $(b (div b 2)) 2))
  --
::
++  rap
  ~.  %rap
  |=  [a=*bloq b=*(list <@>)]
  ^-  @
  ?~  b
    0
  (cat a i.b $(b t.b))
::
++  rip
  ~.  %rip
  |=  [a=*bloq b=@]
  ^-  *(list <@>)
  ?:  .=(0 b)
    ~
  [(end a 1 b) $(b (rsh a 1 b))]
::
++  rsh
  ~.  %rsh
  |=  [a=*bloq b=@ c=@]
  (div c (bex (mul (bex a) b)))
::
++  vor
  ~.  %vor
  |=  [a=* b=*]
  ^-  ?
  =+  [c=(mug (mug a)) d=(mug (mug b))]
  ?:  .=(c d)
    (dor a b)
  (lth c d)
::
  ::  Tier 4, associative containers
::
++  set   |*(a=<*> (tree a))
++  map   |*([a=<*> b=<*>] (tree <[p=*a q=*b]>))
++  in
  ~.  %in
  &=  a=*(set)
  +-  all
    ~.  %all
    |*  b=|=(* ?)
    |-  ^-  ?
    ?~  a
      &
    ?&((b n.a) $(a l.a) $(a r.a))
  ::
  +-  any
    ~.  %any
    |*  b=|=(* ?)
    |-  ^-  ?
    ?~  a
      |
    ?|((b n.a) $(a l.a) $(a r.a))
  ::
  +-  gas
    ~.  %gas
    |*  b=*(list)
    |-  ^-  a
    ?~  b
      a
    $(b t.b, a (put i.b))
  ::
  +-  has
    ~.  %has
    |*  b=*
    |-  ^-  ?
    ?~  a
      |
    ?:  .=(b n.a)
      &
    ?:  (hor b n.a)
      $(a l.a)
    $(a r.a)
  ::
  +-  put
    ~.  %put
    |*  b=*
    |-  ^-  a
    ?~  a
      [b ~ ~]
    ?:  .=(b n.a)
      a
    ?:  (hor b n.a)
      =+  c=$(a l.a)
      ?>  ?=(^ c)
      ?:  (vor n.a n.c)
        [n.a c r.a]
      [n.c l.c [n.a r.c r.a]]
    =+  c=$(a r.a)
    ?>  ?=(^ c)
    ?:  (vor n.a n.c)
      [n.a l.a c] 
    [n.c [n.a l.a l.c] r.c]
  ::
  +-  tap
    ~.  %tap
    |=  b=`*(list <?>(?=(^ a) n.a)>)`~
    ^-  b
    ?~  a
      b
    $(a r.a, b [n.a $(a l.a)])
  ==
::
++  by
  ~.  %by
  &=  a=*(map)
  +-  all
    ~.  %all
    |*  b=|=(* ?)
    |-  ^-  ?
    ?~  a
      &
    ?&((b q.n.a) $(a l.a) $(a r.a))
  ::
  +-  any
    ~.  %any
    |*  b=|=(* ?)
    |-  ^-  ?
    ?~  a
      |
    ?|((b q.n.a) $(a l.a) $(a r.a))
  ::
  +-  gas
    ~.  %gas
    |*  b=*(list <[p=* q=*]>)
    |-  ^-  a
    ?~  b
      a
    $(b t.b, a (put p.i.b q.i.b))
  ::
  +-  get
    ~.  %get
    |*  b=*
    |-  ^-  *<~ [~ u=?>(?=(^ a) q.n.a)]>
    ?~  a
      ~
    ?:  .=(b p.n.a)
      [~ u=q.n.a]
    ?:  (gor b p.n.a)
      $(a l.a)
    $(a r.a)
  ::
  +-  has
    ~.  %has
    |*  b=*
    !.=(~ (get b))
  ::
  +-  put
    ~.  %put
    |*  [b=* c=*]
    |-  ^-  a
    ?~  a
      [[b c] ~ ~]
    ?:  .=(b p.n.a)
      ?>  .=(c q.n.a)
      a
    ?:  (gor b p.n.a)
      =+  d=$(a l.a)
      ?>  ?=(^ d)
      ?:  (vor n.a n.d)
        [n.a d r.a]
      [n.d l.d [n.a r.d r.a]]
    =+  d=$(a r.a)
    ?>  ?=(^ d)
    ?:  (vor n.a n.d)
      [n.a l.a d] 
    [n.d [n.a l.a l.d] r.d]
  ::
  +-  tap
    ~.  %tap
    |=  b=`*(list <?>(?=(^ a) n.a)>)`~
    ^-  b
    ?~  a
      b
    $(a r.a, b [n.a $(a l.a)])
  ==
::
  ::  Tier 5, parsing and pretty-printing
::
::
  ::  Tier 5a, core 0, prototypes
::
++  char  <@>
++  clip  <[p=*hair q=*tape]>
++  edge  <[p=*hair q=*(unit <[p=* q=*tape]>)]>
++  hair  <[p=`@`1 q=`@`1]>
++  rock  <@>
++  rule  |=(p=*clip `*edge`[p.p ~ ~ q.p])
++  tape  (list char)
++  term  <@>
++  wall  (list tape)
::
  ::  Tier 5a, core 1, general parsing
::
++  bass
  |*  [rum=@ tyd=rule]
  %+  cook
    |=  waq=*tape
    %+  roll
      waq
    =+([p=@ q=@] |.((add p (mul rum q))))
  tyd
::
++  boss
  |*  [rum=@ tyd=rule]
  %+  cook
    |=  waq=*tape
    %+  reel
      waq
    =+([p=@ q=@] |.((add p (mul rum q))))
  tyd
::
++  bend
  |*  raq=|=([a=* b=*] [a b])
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    vex 
  =+  yit=(sab p.vex q.u.q.vex)
  ?~  q.yit
    [p=p.yit q=q.vex]
  [p=p.yit q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]
::
++  cold
  |*  [cus=* sef=rule]
  |=  tub=*clip
  =+  vex=(sef tub)
  ?~  q.vex
    vex
  [p=p.vex q=[~ u=[p=cus q=q.u.q.vex]]]
::
++  comp
  |*  raq=|*([a=* b=*] [a b])
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    vex
  =+  yit=(sab p.vex q.u.q.vex)
  ?~  q.yit
    yit
  [p=p.yit q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]
::
++  cook
  |*  [poq=<*> sef=rule]
  |=  tub=*clip
  =+  vex=(sef tub)
  ?~  q.vex
    vex
  [p=p.vex q=[~ u=[p=(poq p.u.q.vex) q=q.u.q.vex]]]
::
++  easy
  |*  huf=*
  |=  tub=*clip
  ^-  *(like <huf>)
  [p=p.tub q=[~ u=[p=huf q=q.tub]]]
::
++  fail  |=(tub=*clip [p=p.tub q=~])
++  glue
  |*  bus=rule
  |*  [vex=*edge sab=rule]
  (plug vex ;~(pfix bus sab))
::
++  ifix
  |*  [fel=[p=rule q=rule] hof=rule]
  ;~(pfix p.fel ;~(sfix hof q.fel))
::
++  just
  |=  daf=*char
  |=  tub=*clip
  ^-  *(like char)
  ?~  q.tub
    (fail tub) 
  ?.  .=(daf i.q.tub)
    (fail tub)
  [(slip i.q.tub p.tub) [~ i.q.tub t.q.tub]]
::
++  know  |*(vex=*edge ?~(q.vex !! p.u.q.vex))
++  like
  |*  a=<*>
  |=  b=*
  [p=(hair -.b) q=?~(+.b ~ [~ u=[p=(a +>-.b) q=(tape +>+.b)]])]
::
++  last
  |=  [zyc=*hair naz=*hair]
  ^-  *hair
  ?:  .=(p.zyc p.naz)
    ?:((gth q.zyc q.naz) zyc naz)
  ?:((gth p.zyc p.naz) zyc naz)
::
++  mask
  |=  bud=*(list char)
  |=  tub=*clip
  ^-  *(like char)
  ?~  q.tub
    (fail tub) 
  ?.  (lien bud |=(a=*char .=(i.q.tub a)))
    (fail tub)
  [(slip i.q.tub p.tub) [~ i.q.tub t.q.tub]]
::
++  mend
  |*  [sef=rule zil=*(list <[p=|=([a=* b=*] [a b]) q=rule]>)]
  |=  tub=*clip
  =+  vex=(sef tub)
  ?~  q.vex
    vex
  =<  $
  &.
  +-  $
    ?~  zil
      [p=p.vex q=~]
    =+  lig=(q.i.zil tub) 
    ?~  q.lig
      $(zil t.zil)
    [p=p.lig q=[~ u=[p=(p.i.zil p.u.q.vex p.u.q.lig) q=q.u.q.lig]]]
  ==
::
++  more
  |*  [bus=rule fel=rule]
  ;~(pose (most bus fel) (easy ~))
::
++  most
  |*  [bus=rule fel=rule]
  ;~(plug fel (star ;~(pfix bus fel)))
::
++  pfix
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    vex
  (sab p.vex q.u.q.vex)
::
++  plug  *comp
++  plus  |*(fel=rule ;~(plug fel (star fel)))
++  pose
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    =+  roq=$:sab
    ?~  q.roq
      [p=(last p.vex p.roq) q=~]
    roq
  vex
::
++  posh
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    ~|('off posh' !!)
  vex
::
++  rash  |*([naf=@ sab=rule] (rasp (rip 3 naf) sab))
++  rasp
  |*  [los=*tape sab=rule]
  =+  vex=(sab *hair los)
  ?~  q.vex
    ~~  `*bill`[%grip ['[' ']'] ~(dem go p.p.vex) ~(dem go q.p.vex) ~]
    ~|('syntax error/a' !!)
  ?.  .=(~ q.u.q.vex) 
    ~~  `*bill`[%grip ['[' ']'] ~(dem go p.p.vex) ~(dem go q.p.vex) ~]
    ~|('syntax error/b' !!)
  p.u.q.vex
::
++  sfix
  |*  [vex=*edge sab=rule]
  ?~  q.vex
    vex
  =+  yit=(sab p.vex q.u.q.vex)
  ?~  q.yit
    yit
  [p=p.yit q=[~ u=[p=p.u.q.vex q=q.u.q.yit]]]
::
++  shim
  |=  zep=[p=*char q=*char]
  |=  tub=*clip
  ^-  *(like char)
  ?~  q.tub
    (fail tub) 
  ?.  ?&((gte i.q.tub p.zep) (lte i.q.tub q.zep))
    (fail tub)
  [(slip i.q.tub p.tub) [~ i.q.tub t.q.tub]]
::
++  slip
  |=  [weq=*char naz=*hair]
  ^-  *hair
  ?:  .=(10 weq)
    [.+(p.naz) 1]
  [p.naz .+(q.naz)]
::
++  slug
  |*  [rud=* raq=|*([a=* b=*] [a b])]
  |*  [bus=rule fel=rule]
  ;~((comp raq) fel (stir rud raq ;~(pfix bus fel)))
::
++  stag
  |*  [gob=* sef=rule]
  |=  tub=*clip
  =+  vex=(sef tub)
  ?~  q.vex
    vex
  [p=p.vex q=[~ u=[p=[gob p.u.q.vex] q=q.u.q.vex]]]
::
++  star
  |*  fel=rule
  (stir `*(list <(know *fel)>)`~ |*([a=* b=*] [a b]) fel)
::
++  stir
  |*  [rud=* raq=|*([a=* b=*] [a b]) fel=rule]
  |=  tub=*clip 
  ^-  *(like <rud>)
  =+  vex=(fel tub) 
  ?~  q.vex
    [p.tub [~ rud q.tub]]
  =+  wag=$(p.tub p.vex, q.tub q.u.q.vex)
  ?>  ?=(^ q.wag)
  [p.wag [~ (raq p.u.q.vex p.u.q.wag) q.u.q.wag]]
::
  ::  Tier 5a, core 2, ASCII
::
++  ace  (just ' ')
++  alf  ;~(pose low hig)
++  aln  ;~(pose low hig num)
++  bar  (just '|')
++  bet  ;~(pose (cold 2 dap) (cold 3 pad))
++  bin  (bass 2 (plus bit))
++  bit  (cook |=(a=@ (sub a '0')) (shim '0' '1'))
++  bon  (just '=')
++  bot  (just '\'')
++  cab  (just '_')
++  com  (just ',')
++  cas  (just '?')
++  dap  (just '-')
++  dax  (just '#')
++  deg  (just ':')
++  den  (just '[')
++  des  (just '{')
++  dot  (just '.')
++  del  (just '<')
++  dem  (bass 10 (plus dit))
++  dit  (cook |=(a=@ (sub a '0')) (shim '0' '9'))
++  gal  ;~(pose (cold 2 del) (cold 3 led))
++  gap  (cold ~ (plus ;~(pose vul (mask [10 32 ~]))))
++  gay  ;~(pose gap (easy ~))
++  hex  (bass 16 (plus hit))
++  hig  (shim 'A' 'Z')
++  hit  ;~(pose dit (cook |=(a=*char (sub a 87)) (shim 'a' 'f')))
++  ket  (just '^')
++  lep  (just '(')
++  led  (just '>')
++  low  (shim 'a' 'z')
++  mes  (cook |=([a=@ b=@] (add (mul 16 a) b)) ;~(plug hit hit))
++  mit  (just '%')
++  nat  (just '@')
++  ned  (just ']')
++  nix  (boss 256 (star ;~(pose aln cab)))
++  nov  (just '\\')
++  num  (shim '0' '9')
++  pad  (just '+')
++  pam  (just '&')
++  pel  (just ')')
++  poy  ;~(pfix nov ;~(pose nov bot mes))
++  qit  ;~(pose (shim 32 38) (shim 40 91) (shim 92 126) poy)
++  quo  (ifix [bot bot] (bass 256 (plus qit)))
++  sec  (just '$')
++  sed  (just '}')
++  sig  (just '~')
++  sym 
  %+  cook
    |=(a=*tape (rap 3 a))
  ;~(plug low (star ;~(pose num low dap)))
::
++  tam  (just ';')
++  tar  (just '*')
++  tec  (just '`')
++  tob  (just '"')
++  ven
  ;~  (comp |=([a=@ b=@] (peg a b)))
    bet
    =+  hom=`?`|
    |=  tub=*clip
    ^-  *(like axis)
    =+  vex=?:(hom (bet tub) (gal tub))
    ?~  q.vex
      [p.tub [~ 1 q.tub]] 
    =+  wag=$(p.tub p.vex, hom !hom, q.tub q.u.q.vex)
    ?>  ?=(^ q.wag)
    [p.wag [~ (peg p.u.q.vex p.u.q.wag) q.u.q.wag]]
  -- 
++  von  (just '/')
++  vul  (cold ~ ;~(plug deg deg (star (shim 32 126)) (just 10)))
++  zap  (just '!')
::
  ::  Tier 5b, core 0, prototypes
::
++  tank
  |?  [%leaf p=*tape]
      [%palm p=[p=*tape q=*tape r=*tape s=*tape] q=*(list tank)]
      [%rose p=[p=*tape q=*tape r=*tape] q=*(list tank)]
      :: [%farm p=[p=*tape q=*tape r=*tape] q=*(list (list tank))]
  --
::
  ::  Tier 5b, core 1, processors
::
++  re
  &=  tec=*tank
  ++  ram
    ^-  *tape
    ?-    -.tec
        %leaf  p.tec
        %palm  ram(tec [%rose [p.p.tec (weld q.p.tec r.p.tec) s.p.tec] q.tec])
        %rose
      %+  weld
        q.p.tec
      |-  ^-  *tape
      ?~  q.tec
        r.p.tec
      =+  voz=$(q.tec t.q.tec)
      (weld ram(tec i.q.tec) ?~(t.q.tec voz (weld p.p.tec voz)))
    --
  ::
  ++  win
    |=  [tab=@ edg=@]
    ^-  *wall
    =+  lug=`*wall`~
    &-  |- 
        ?-    -.tec
            %leaf  (wind [tab edg] p.tec lug)
            %palm  !!
            %rose
          ?:  fit
            (rig ram)
          %-  %=    rig
                  lug
                |-  ^-  *wall
                ?~  q.tec
                  (rig r.p.tec)
                $$(tec i.q.tec, lug $(q.tec t.q.tec), tab din)
              --
          q.p.tec
        --
    ::
    ++  din  (mod (add 2 tab) (mul 2 (div edg 3)))
    ++  fit  (lte (lent ram) (sub edg tab))
    ++  rig
      |=  hom=*tape
      ^-  *wall
      ?:  (lte (lent hom) (sub edg tab))
        [(runt [tab 32] hom) lug]
      =>  .(tab (add tab 2), edg (sub edg 2))
      =+  mut=(trim (sub edg tab) hom)
      :-  (runt [(sub tab 2) 32] [92 47 (weld p.mut `hom`[92 47 ~])])
      =>  .(hom q.mut)
      |-
      ?~  hom
        :-  (runt [(sub tab 2) 32] [92 47 (runt [(sub edg tab) 32] [92 47 ~])])
        lug
      =>  .(mut (trim (sub edg tab) hom))
      [(runt [tab 32] p.mut) $(hom q.mut)]
    ==
  ==
::
++  slyb  (slym 2 |=(a=@ (add '0' a)))
++  slyd  (slym 10 |=(a=@ (add '0' a)))
++  slym
  |=  [a=@ b=|+(@ @)]
  |=  c=@
  ^-  *(list <@>)
  ?:  .=(0 c)
    [(b 0) ~]
  =+  d=`*(list <@>)`~
  |-
  ?:  .=(0 c)
    d
  $(c (div c a), d [(b (mod c a)) d])
::
++  slys  |=(a=@ `*tape`[39 (weld (mesc (rip 3 a)) `*tape`[39 ~])])
++  slyp
  |=  a=@
  ^-  *tape
  =+  b=(met 3 a)
  &-  |-  ^-  *tape
      ?:  (gth (met 5 a) 1)
        %+  weld
          $(a (rsh 5 1 a), b (sub b 4)) 
        `*tape`['-' '-' $(a (end 5 1 a), b 4)]
      ?:  (lte b 1)
        fon
      |-  ^-  *tape
      ?:  .=(2 b)
        =+  c=(rsh 3 1 a)
        =+  d=(end 3 1 a)
        (weld fon(a (mix c d)) nof(a d))
      =+  c=(rsh 3 2 a)
      =+  d=(end 3 2 a)
      (weld $(a (mix c d), b 2) `*tape`['-' $(a d, b 2)])
  ::
  ++  fon
    ^-  *tape
    :~  (cut 3 [(cut 0 [0 3] a) 1] %bkflmtdy)
        (cut 3 [(cut 0 [3 2] a) 1] %oaie)
        (cut 3 [(cut 0 [5 3] a) 1] %xvsrpngw)
    --
  ::
  ++  nof
    ^-  *tape
    :~  (cut 3 [(cut 0 [0 3] a) 1] %yvswpmqd)
        (cut 3 [(cut 0 [3 2] a) 1] %euia)
        (cut 3 [(cut 0 [5 3] a) 1] %bcflntrz)
    --
  ==
::
++  slyq
  |=  a=@
  ^-  *tape
  ?:  ?&  (gte (met 3 a) 2)
          |-
          ?:  .=(0 a)
            &
          =+  vis=(end 3 1 a)
          ?&(?|(.=('-' vis) ?&((gte vis 'a') (lte vis 'z'))) $(a (rsh 3 1 a)))
      --
    (slys a)
  ?:  (lte (met 3 a) 2)
    (slyd a)
  (slyx a)
::
++  slyv
  %+  slym
    64
  |=  a=@
  ?:  .=(62 a) 
    45 
  (add a ?:((lth a 26) 65 ?:((lth a 52) 71 ?:((lth a 62) 4 32))))
::
++  slyx  (slym 16 |=(a=@ (add a ?:((lth a 10) 48 87))))
++  ship
  |=  [fom=@ gar=*]
  ^-  *tank
  =+  l=(met 3 fom)
  =+  i=`@`0
  :-  %leaf
  |-  ^-  *tape
  ?:  (gte i l)
    ~
  =+  c=(cut 3 [i 1] fom)
  ?.  .=(37 c)
    (weld (mesc [c ~]) $(i .+(i)))
  =+  d=(cut 3 [.+(i) 1] fom)
  ?.  .?(gar)
    [92 35 $(i (add 2 i))]
  (weld ~(ram re (show d -.gar)) $(i (add 2 i), gar +.gar))
::
++  shop
  |=  [aug=* vel=|+(a=@ *tape)]
  ^-  *tank
  ?:  ?=(@ aug)
    [%leaf (vel aug)]
  :+  %rose 
    [[' ' ~] ['[' ~] [']' ~]]
  |-  ^-  *(list tank)
  ?:  ?=(@ aug)
    [$$ ~]
  [$$(aug -.aug) $(aug +.aug)]
::
++  show
  |=  vem=*
  ^-  *tank
  ?:  ?=(@ vem)
    [%leaf (mesc (rip 3 vem))]
  ?-    vem
      [s=~ c=*]         [%leaf 39 (weld (mesc (tape +.vem)) `*tape`[39 ~])]
      [s=%b c=*]        (shop c.vem slyb)
      [s=%d c=*]        (shop c.vem slyd)
      [s=%p c=*]        (shop c.vem slyp)
      [s=%q c=*]        (shop c.vem slyq)
      [s=%r c=*]        $(vem [[%r ' ' '{' '}'] c.vem])
      [s=%s c=*]        (shop c.vem slys)
      [s=%v c=*]        (shop c.vem slyv)
      [s=%x c=*]        (shop c.vem slyx)
  ::
      [s=[%m p=@] c=*]  (ship p.s.vem c.vem)
      [s=[%r p=@] c=*]
    $(vem [[%r ' ' (cut 3 [0 1] p.s.vem) (cut 3 [1 1] p.s.vem)] c.vem])
  ::
      [s=[%r p=@ q=@ r=@] c=*]
    :+  %rose
      :*  p=(mesc (rip 3 p.s.vem))
          q=(mesc (rip 3 q.s.vem))
          r=(mesc (rip 3 r.s.vem))
      --
    |-  ^-  *(list tank)
    ?~  c.vem
      ~
    [$$(vem -.c.vem) $(c.vem +.c.vem)]
  --
::
++  mesc
  |=  vib=*tape
  ^-  *tape
  ?~  vib
    ~
  ?:  .=(92 i.vib)
    [92 92 $(vib t.vib)]
  ?:  ?|((gth i.vib 126) (lth i.vib 32) .=(39 i.vib))
    [92 (weld (slyx i.vib) (runt [1 47] $(vib t.vib)))]
  [i.vib $(vib t.vib)]
::
++  runt
  |=  [[a=@ b=@] c=*tape]
  ^-  *tape
  ?:  .=(0 a)
    c
  [b $(a (dec a))]
::
::
++  trim
  |=  [a=@ b=*tape]
  ^-  [p=*tape q=*tape]
  ?~  b
    [~ ~]
  ?:  .=(0 a)
    [~ b]
  =+  c=$(a (dec a), b +.b)
  [[-.b p.c] q.c]
::
++  wind
  |=  [[tab=@ edg=@] hom=*tape wol=*wall]
  ^-  *wall
  =>  .(tab (mod tab (mul 2 (div edg 3))))
  ?:  (lte (lent hom) (sub edg tab))
    [(runt [tab 32] hom) wol]
  =>  .(tab (add tab 2), edg (sub edg 2))
  =+  mut=(trim (sub edg tab) hom)
  :-  (runt [(sub tab 2) 32] [92 47 (weld p.mut `hom`[92 47 ~])])
  =>  .(hom q.mut)
  |-
  ?~  hom
    [(runt [(sub tab 2) 32] [92 47 (runt [(sub edg tab) 32] [92 47 ~])]) wol]
  =>  .(mut (trim (sub edg tab) hom))
  [(runt [tab 32] p.mut) $(hom q.mut)]
::::
::::
++  bill
  |?
    ^+(@ *rock)
    [%duct p=*tape]
    [%grip p=[p=*rock q=*rock] q=*(list bill)]
    [%meld p=*(list bill)]
  --
::
::
++  to
  ~%    %to  
      ->  
    (%wit wit, %ram ram, %fly fly)
  &=  pup=*bill
  ++  fly
    ~.  %fly
    |=  bor=@
    ^-  *wall
    =+  col=@
    =>  &.
        ++  ind
          |=  tep=*tape
          ^-  *tape
          ?:(.=(0 col) tep $(col (dec col), tep [' ' tep]))
        ==
    =+  lux=*wall
    |-  ^-  *wall
    ?.  ?&(?=([%grip *] pup) (gte (add col wit) bor))
      [(ind ram) lux]
    :-  (ind (rip 3 p.p.pup))
    |-  ^-  *wall
    ?~  q.pup
      [(ind (rip 3 q.p.pup)) lux]
    %=  $$
      pup   i.q.pup
      lux   $(q.pup t.q.pup)
      col   ?:((gte col (mul 2 (div bor 3))) 0 (add 2 col))
    --
  ::
  ++  ram
    ^-  *tape
    ?-    pup 
        @           (rip 3 pup)
        [%duct *]   p.pup 
        [%meld *]   (reel p.pup =+([p=*bill q=*tape] |.((weld ram(pup p) q))))
        [%grip *]
      %+  weld
        (rip 3 p.p.pup)
      |-  ^-  *tape
      ?-  q.pup
        ~       (rip 3 q.p.pup)
        [* ~]   (weld ram(pup i.q.pup) (rip 3 q.p.pup))
        ^       (weld ram(pup i.q.pup) `*tape`[' ' $(q.pup t.q.pup)])
      --
    --
  ::
  ++  wit
    ^-  @
    ?-    pup
        @           (met 3 pup)
        [%duct *]   (lent p.pup)
        [%grip *]
      %+  add
        (add (met 3 p.p.pup) (met 3 q.p.pup))
      %+  roll
        q.pup
      =+([p=*bill q=@] |.((add ?:(.=(0 q) 0 1) (add q wit(pup p)))))
    ::
        [%meld *]   (roll p.pup =+([p=*bill q=@] |.((add q wit(pup p)))))
    -- 
  ==
::
++  go
  ~%    %go  
      ->  
    (%dem dem, %gut gut, %ham ham, %loc loc, %num num, %tis tis, %unt unt)
  &=  nut=*
  +-  dem   (num 10 |=(p=@ (add '0' p)))
  +-  gut
    |-  ^-  *bill
    ?-  nut
        @   unt
        ^
      :+  %grip
        ['[' ']']
      |-  ^-  *(list bill)
      ?-  nut
        [* @]   [$$(nut -.nut) $$(nut +.nut) ~]
        [* ^]   [$$(nut -.nut) $(nut +.nut)]
      --
    --
  ::
  +-  ham   (num 16 |=(p=@ ?:((lth 10 p) (add '0' p) (add 'a' p))))
  +-  loc
    ^-  *bill
    ?>  ?=([p=@ q=[p=[p=@ q=@] q=[p=@ q=@]]] nut)   :: should be static
    :+  %grip
      ['<' '>']
    =+  ^=  rov
        :~  [%grip ['[' ']'] dem(nut p.p.q.nut) dem(nut q.p.q.nut) ~]
            [%grip ['[' ']'] dem(nut p.q.q.nut) dem(nut q.q.q.nut) ~]
        --
    ?:  .=(%% p.nut)
      rov
    [p.nut rov]
  ::
  +-  num
    |*  [zel=@ hoz=|=(@ @)]
    ^-  [%duct p=*tape]
    :-  %duct
    ?:  .=(0 nut)
      [(hoz 0) ~]
    =+  biq=`*tape`~
    |-  ^-  *tape
    ?:  .=(0 nut)
      biq
    $(nut (div nut zel), biq [(hoz (mod nut zel)) biq])
  ::
  +-  tem
    ^-  [%duct p=*tape]
    :-  %duct
    |-  ^-  *tape
    ?:  .=(0 nut)
      ~
    [(end 3 1 nut) $(nut (rsh 3 1 nut))]
  ::
  +-  tis
    [%duct p=nut]
  ::
  +-  unt
    ^-  [%duct p=*tape]
    ?:  ?&  (gte (met 3 nut) 2)
            |-
            ?:  .=(0 nut)
              &
            =+  vis=(end 3 1 nut)
            =+  goz=(rsh 3 1 nut)
            ?&(?|(.=('-' vis) ?&((gte vis 'a') (lte vis 'z'))) $(nut goz))
        --
      =<([- ['%' +]] tem)
    ?:  (lte (met 3 nut) 2)
      dem
    ham
  ==
::
  ::  Tier 6, Watt in Watt
::
++  cell
  ~.  %cell
  |=  [hed=*type tal=*type]
  ^-  *type
  ?:  .=(%void hed)
    %void
  ?:  .=(%void tal)
    %void
  [%cell hed tal]
::
++  chop
  ~.  %chop
  |?  lef=^+(@ *term) 
      [std=^+(@ *term) kel=@]
      [ven=^+(@ *term) pro=^+(@ *term) kel=@]
      [ven=^+(@ *term) pro=^+(@ *term) ver=@ kel=@]
  --
::
++  core
  ~.  %core 
  |=  [pac=*type con=*cone]
  ^-  *type
  ?:(.=(%void pac) %void [%core pac con])
::
++  cone
  |?
    :+    p=*<%gold %lead %iron %wood>
        q=*type
      r=[p=*<~ ^> q=*(map term foot)]
  --
::
++  face
  ~.  %face
  |=  [cog=*term der=*type] 
  ^-  *type
  ?:  .=(%void der)
    %void
  [%face cog der]
::
++  flag  ^-(*type [%fork [%cube 0] [%cube 1]])
++  foot  <[& p=*gate] [| p=*(map term foot)]>
++  fork
  ~.  %fork
  |=  [hoz=*type bur=*type]
  ^-  *type
  ?:  .=(hoz bur)
    hoz
  ?:  .=(%void hoz)
    bur
  ?:  .=(%void bur)
    hoz
  [%fork hoz bur]
::
++  form
  |?  [0 p=@]
      [1 p=*]
      [2 p=*form q=*form]
      [3 p=*form]
      [4 p=*form]
      [5 p=*form q=*form]
      [6 p=*form q=*form r=*form]
      [7 p=*form q=*form]
      [8 p=*form q=*form]
      [9 p=@ q=*form]
      [10 p=*<@ [p=@ q=*form]> q=*form]
      [p=^+(^ *form) q=*form]
  --
++  gate  <[p=? q=*gene]>
++  gene
  |?
    ^+(@ *term)
    [~ p=^+(@ *axis)]
  ::
    [%bndl p=*gene q=*gene]                                       ::  =<  bondel
    [%bndp p=*gene q=*gene]                                       ::  =-  bondap
    [%bnpd p=*gene q=*gene]                                       ::  =+  bonpad
    [%bnld p=*gene q=*gene]                                       ::  =>  bonled
  ::
    [%brbn p=*gene q=*gene]                                       ::  |=  barbon
    [%brcs p=*(list gene)]                                        ::  |?  barcas
    [%brdg p=*gene q=*gene]                                       ::  |:  bardeg
    [%brdp p=*gene]                                               ::  |-  bardap
    [%brdt p=*gene]                                               ::  |.  bardot
    [%brpd p=*gene q=*gene]                                       ::  |+  barpad
    [%brtr p=*gene q=*gene]                                       ::  |*  bartar
  ::
    [%csbn p=*gene q=*gene]                                       ::  ?=  casbon
    [%csbr p=*(list gene)]                                        ::  ?|  casbar
    [%csdg p=*gene q=*gene r=*gene]                               ::  ?:  casdeg
    [%csdl p=*gene q=*gene]                                       ::  ?<  casdel
    [%csdt p=*gene q=*gene r=*gene]                               ::  ?.  casdot
    [%csld p=*gene q=*gene]                                       ::  ?>  casled
    [%csdp p=*gene q=*(list <[p=*gene q=*gene]>)]                 ::  ?-  casdap
    [%cspm p=*(list gene)]                                        ::  ?&  caspam
    [%cstr p=*gene q=*(list gene)]                                ::  ?*  castar
    [%cssg p=*gene q=*gene r=*gene]                               ::  ?~  cassig
    [%cszp p=*gene]                                               ::  ?!  caszap
  ::
    [%dgkt p=*gene q=*gene r=*gene s=*gene]                       ::  :^  degket
    [%dgdp p=*gene q=*gene]                                       ::  :-  degdap
    [%dgpd p=*gene q=*gene r=*gene]                               ::  :+  degpad
    [%dgsg p=*(list gene)]                                        ::  :~  degsig
    [%dgtr p=*(list gene)]                                        ::  :*  degtar
  :: 
    [%dtbn p=*gene q=*gene]                                       ::  .=  dotbon
    [%dtcs p=*gene]                                               ::  .?  dotcas
    [%dtpd p=*gene]                                               ::  .+  dotket
    [%dtsg p=*]                                                   ::  .~  dotsig
    [%dttr p=*gene q=*gene]                                       ::  .*  dottar
  ::
    [%ktbn p=*term q=*gene]                                       ::  ^=  ketbon
    [%ktdp p=*gene q=*gene]                                       ::  ^-  ketdap
    [%ktpd p=*gene q=*gene]                                       ::  ^+  ketpad
    [%ktsg p=*gene]                                               ::  ^~  ketsig
::
    [%mtbn p=*twig q=*(list <[p=*gene q=*gene]>)]                 ::  %=  mitbon
    [%mtbr p=*twig q=*gene r=*(list <[p=*gene q=*gene]>)]         ::  %|  mitbar
    [%mtdg p=*gene q=*gene]                                       ::  %:  mitdeg
    [%mtdt p=*gene q=*gene]                                       ::  %.  mitdot
    [%mtkt p=*gene q=*gene r=*gene s=*gene]                       ::  %^  mitket
    [%mtdp p=*gene q=*(list gene)]                                ::  %-  mitdap
    [%mtpd p=*gene q=*gene r=*gene]                               ::  %+  mitpad
    [%mtsg p=*twig q=*gene r=*gene]                               ::  %~  mitsig
    [%mttr p=*gene]                                               ::  %*  mittar
  ::
    [%pmbn p=*gene q=*(map term foot)]                            ::  &=  pambon
    [%pmdg p=*gene q=*(map term foot)]                            ::  &:  pamdeg
    [%pmdp p=*gene q=*(map term foot)]                            ::  &-  pamdap
    [%pmdt p=*(map term foot)]                                    ::  &.  pamdot
    [%pmpd p=*gene q=*(map term foot)]                            ::  &+  pampad
  ::
    [%sgbn p=*gene q=*gene]                                       ::  ~=  sigbon
    [%sgbr p=*gene q=*gene]                                       ::  ~|  sigbar
    [%sgdg p=[p=@ q=@] q=*gene]                                   ::  ~:  sigdeg
    [%sgdt p=*chop q=*gene]                                       ::  ~%  sigdot
    [%sgdl p=*<^+(@ *term) [p=*term q=*gene]> q=*gene]            ::  ~>  sigdel
    [%sgdp p=@ q=*gene]                                           ::  ~-  sigdap
    [%sgdx p=*gene]                                               ::  ~#  sigdax
    [%sgkt p=*gene]                                               ::  ~^  sigket
    [%sgld p=*<^+(@ *term) [p=*term q=*gene]> q=*gene]            ::  ~>  sigled
    [%sgmt p=*chop q=*gene r=*(list <[p=*term q=*gene]>) s=*gene] ::  ~%  sigmit
    [%sgpd p=@ q=*gene]                                           ::  ~+  sigpad
    [%sgpm p=*gene q=*gene]                                       ::  ~&  sigpam
    [%sgsg p=*gene q=*gene]                                       ::  ~~  sigsig
  ::
    [%tmbn p=*<%atom %noun %cell %flag %null>]                    ::  ;=  tambon
    [%tmdp p=*gene]                                               ::  ;-  tamdap
    [%tmpd p=*gene q=*gene]                                       ::  ;+  tampad
    [%tmsg p=*gene q=*(list gene)]                                ::  ;~  tamsig
    [%tmtr p=*gene q=*gene]                                       ::  ;*  tamtar
  ::
    [%zpbn p=*gene]                                               ::  !=  zapbon
    [%zpdx p=*gene]                                               ::  !#  zapdax
    [%zpcb p=*spot q=*gene]                                       ::  !_  zapcab
    [%zpzp ~]                                                     ::  !!  zapzap
  --
::
++  knot  <^+(@ *term) [~ p=*axis]>
++  port  |?  :-  p=*axis 
              q=*<[& p=*type] [| p=*axis q=*(list <[p=*type q=*gate]>)]>
          --
++  spot  <[p=@ q=[p=[p=@ q=@] q=[p=@ q=@]]]>
++  twig  (list knot)
++  type
  |?  %atom
      [%cell p=*type q=*type]
      [%core p=*type q=*cone]
      [%cube p=*]
      [%face p=*term q=*type]
      [%fork p=*type q=*type]
      [%hold p=*(list <[p=*type q=*gene]>)]
      %noun
      %void
  --
::
++  ap
  ~%  %ap  ->  (%mold mold, %open open, %rake rake, %sift sift)
  &=  gen=*gene
  ++  mold
    ~.  %mold
    |=  hep=*twig
    ^-  *gene
    ?-    gen
        [%dgdp *]
      :+  %dgdp
        $(gen p.gen, hep [[~ 2] hep])
      $(gen q.gen, hep [[~ 3] hep])
    :: 
        [%ktbn *]   [%ktbn p.gen $(gen q.gen)]
        [%ktdp *]   $(gen p.gen)
        [%ktpd *]   [%ktpd p.gen $(gen q.gen)]
        [%mttr *]   [%mtdp p.gen [%mtbn hep ~] ~]
        [%zpcb *]   [%zpcb p.gen $(gen q.gen)]
        [%zpdx *]   [%zpdx $(gen p.gen)]
        *
      =+  bog=~(open ap gen)
      ?.  .=(bog gen)
        $(gen bog)
      [%csld [%csbn gen [%mtbn hep ~]] [%mtbn hep ~]]
    --
  ++  open
    ^-  *gene
    ?-    gen
        @           [%mtbn [gen ~] ~]
        [~ *]       [%mtbn [gen ~] ~]
        [%bndl *]   [%bnld q.gen p.gen]
        [%bndp *]   [%bnpd q.gen p.gen]
        [%bnpd *]   [%bnld [%dgdp p.gen [~ 1]] q.gen]
        [%brbn *]   [%pmbn p.gen [[%% [& & q.gen]] ~ ~]]
        [%brcs *]
      ?~  p.gen
        [%zpzp ~]
      [%brbn [%ktdp [%tmbn %noun] i.p.gen] [%cstr [~ 4] p.gen]]
    ::
        [%brdp *]   [%bnld [%brdt p.gen] %%]
        [%brdg *]   [%pmdg p.gen [[%% [& & q.gen]] ~ ~]]
        [%brdt *]   [%pmdt [[%% [& & p.gen]] ~ ~]]
        [%brpd *]   [%pmpd p.gen [[%% [& & q.gen]] ~ ~]]
        [%brtr *]   [%pmbn p.gen [[%% [& | q.gen]] ~ ~]]
        [%csbr *]
      |- 
      ?~(p.gen [%dtsg 1] [%csdg i.p.gen [%dtsg 0] $(p.gen t.p.gen)])
    ::
        [%csdl *]   [%csdg p.gen [%zpzp ~] q.gen]
        [%csdt *]   [%csdg p.gen r.gen q.gen]
        [%csld *]   [%csdg p.gen q.gen [%zpzp ~]]
        [%csdp *]
      |-
      ?~  q.gen
        [%zpzp ~]
      :^    %csdg
          [%csbn p.i.q.gen p.gen]
        [%bnld [%mtbn ~ [[p.gen [%ktpd p.i.q.gen p.gen]] ~]] q.i.q.gen]
      $(q.gen t.q.gen)
    ::
        [%cspm *]
      |-
      ?~(p.gen [%dtsg 0] [%csdg i.p.gen $(p.gen t.p.gen) [%dtsg 1]])
    ::
        [%cstr *]
      |-
      ?~  q.gen
        [%zpzp ~]
      :^    %csdg
          [%csbn (sift i.q.gen) [%mtbn rake(gen p.gen) ~]]
        (mold(gen i.q.gen) rake(gen p.gen))
      $(q.gen t.q.gen)
    ::
        [%cssg *]   [%csdp p.gen [[[%dtsg 0] q.gen] [[%tmbn %cell] r.gen] ~]]
        [%cszp *]   [%csdg p.gen [%dtsg 1] [%dtsg 0]]
        [%dgkt *]   [%dgdp p.gen [%dgdp q.gen [%dgdp r.gen s.gen]]]
        [%dgpd *]   [%dgdp p.gen [%dgdp q.gen r.gen]]
        [%dgsg *]   |-(?~(p.gen [%dtsg ~] [%dgdp i.p.gen $(p.gen t.p.gen)]))
        [%dgtr *]
      |-
      ?-    p.gen 
          ~       [%zpzp ~]
          [* ~]   i.p.gen
          ^       [%dgdp i.p.gen $(p.gen t.p.gen)]
      --
    ::
        [%mtbr *]
      :+  %bnpd
        q.gen
      :+  %mtbn
        (weld p.gen `*twig`[[~ 2] ~])
      (turn r.gen |=([p=*gene q=*gene] [p [%bnld [~ 3] q]]))
    ::
        [%mtdg *]   [%mtsg [%% ~] p.gen q.gen]
        [%mtdp *]   ?~(q.gen [%bnld p.gen %%] [%mtdg p.gen [%dgtr q.gen]])
        [%mtdt *]   [%mtdp q.gen [p.gen ~]]
        [%mtkt *]   [%mtdp p.gen q.gen r.gen s.gen ~]
        [%mtpd *]   [%mtdp p.gen q.gen r.gen ~]
        [%mtsg *]   [%mtbr p.gen q.gen [[[~ 4] r.gen] ~]]
        [%mttr *]   [%bnld p.gen [%mtbn [%% ~] ~]]
        [%pmdp *]   [%bnld [%pmdt q.gen] p.gen] 
        [%pmbn *]   [%bnpd p.gen [%pmdt q.gen]]
        [%sgbn *]   [%sgld [%germ p.gen] q.gen]
        [%sgbr *]   [%sgld [%bean p.gen] q.gen]
        [%sgdg *]   [%sgld [%bank %dtsg p.gen] q.gen]
        [%sgdl *]   [%bndl [%sgld p.gen [~ 1]] q.gen]
        [%sgdp *]   [%sgld [%sole %dtsg p.gen] q.gen]
        [%sgdt *]   [%sgmt p.gen [~ 5] ~ q.gen]
        [%sgdx *]   [%sgld %ping p.gen]
        [%sgkt *]   [%sgld %keep p.gen]
        [%sgmt *]
      :+  %sgdl
        :-  %fast
        :-  %dgpd
        :+  [%dtsg p.gen]
          [%zpbn q.gen]
        :-  %dgsg
        =+  nob=`*(list gene)`~
        |-  ^-  nob
        ?~  r.gen
          nob
        [[%dgdp [%dtsg p.i.r.gen] [%zpbn q.i.r.gen]] $(r.gen t.r.gen)]
      s.gen
    ::
        [%sgpd *]   [%sgld [%memo %dtsg p.gen] q.gen]
        [%sgpm *]   [%sgld [%loaf p.gen] q.gen]
        [%sgsg *]   [%sgld [%mean [%brdt p.gen]] q.gen]
    ::
        [%tmbn *]
      ?-  p.gen
        %atom   [%ktdp [%dtpd %dtsg 0] [%dtsg 0]]
        %noun   [%ktdp [%dttr [%dtsg 0] [%dtsg 0]] [%dtsg 0]]
        %cell   [%dgdp [%tmbn %noun] [%tmbn %noun]]
        %flag   [%ktdp [%dtcs %dtsg 0] [%dtsg 0]]
        %null   [%dtsg 0]
      --
    ::
        [%tmdp *]   (sift p.gen)
        [%tmpd *]   (mold(gen p.gen) rake(gen q.gen))
        [%tmsg *]
      |-
      ?-  q.gen
          ~       ~|(%open-tmsg !!)
          [* ~]   i.q.gen
      ::
          ^
        :+  %bnpd
          $(q.gen t.q.gen)
        :+  %bnpd
          [%bnld [~ 3] i.q.gen]
        :+  %brbn
          [~ 8]
        :^    %mtpd
            [%bnld [~ 23] p.gen]
          [%mtdp [~ 10] [~ 4] ~]
        [%mtbn [[~ 22] ~] [[[~ 4] [~ 4]] ~]]
      --
    ::
        [%tmtr *]
      =+  req=rake(gen p.gen)
      =+  nus=[%mtbn req ~]
      :*  %brdp
          %cssg
          nus
          [%tmbn %null]
          :+    %mtbn
              req
            :~  [[~ 2] q.gen]
                [[~ 3] [%mtbn [%% ~] [[nus [%mtbn [[~ 3] req] ~]] ~]]]
            --
      --
    ::
        *           gen
    --
  ::
  ++  rake
    ^-  *twig
    ?-  gen
      @             [gen ~]
      [~ *]         [gen ~]
      [%mtbn * ~]   p.gen
      [%zpcb *]     rake(gen q.gen)
      [%zpdx *]     rake(gen p.gen)
    --
  ::
  ++  sift
    ~.  %sift
    |=  gen=*gene
    ^-  *gene
    ?-  gen
        [%dgdp *]   [%dgdp $(gen p.gen) $(gen q.gen)]
        [%dtsg *]   gen
        [%ktbn *]   $(gen q.gen)
        [%ktpd *]   $(gen p.gen)
        [%mttr *]   
      ?.  ?=([%brcs *] p.gen)
        [%tmbn %noun]
      gen(p.p (turn p.p.gen |=(*gene $$(gen -<))))
    ::
        [%tmbn *]   gen
        [%zpcb *]   [%zpcb p.gen $(gen q.gen)]
        [%zpdx *]   [%zpdx $(gen p.gen)]
        *
      =+  bog=~(open ap gen)
      ?:  .=(bog gen)
        [%tmbn %noun]
      $(gen bog)
    --
  ==
::
++  comb
  ~.  %comb
  |=  [mal=*form buz=*form]
  ^-  *form
  ?:  ?&(?=([0 *] mal) !.=(0 p.mal))
    ?:  ?&(?=([0 *] buz) !.=(0 p.buz)) 
      [0 (peg p.mal p.buz)]
    ?:  ?=([2 [0 *] [0 *]] buz)
      [2 [0 (peg p.mal p.p.buz)] [0 (peg p.mal p.q.buz)]]
    [7 mal buz]
  ?:  ?=([^ [0 1]] mal)
    [8 p.mal buz]
  ?:  .=([0 1] buz)
    mal
  [7 mal buz]
::
++  cons
  ~.  %cons
  |=  [vur=*form sed=*form]
  ^-  *form
  ?:  ?=([[0 *] [0 *]] -<)
    ?:  ?&(.=(.+(p.vur) p.sed) .=((div p.vur 2) (div p.sed 2)))
      [0 (div p.vur 2)]
    [vur sed]
  ?:  ?=([[1 *] [1 *]] -<)
    [1 p.vur p.sed]
  [vur sed] 
::
++  flan
  ~.  %flan
  |=  [bos=*form nif=*form]
  ^-  *form
  ?-    bos
      [1 1]   bos
      [1 0]   nif
      *
    ?-    nif
        [1 1]   nif
        [1 0]   bos
        *       [6 bos nif [1 1]]
    --
  --
::
++  flip
  ~.  %flip
  |=  [dyr=*form]
  [6 dyr [1 1] [1 0]]
::
++  flor
  ~.  %flor
  |=  [bos=*form nif=*form]
  ^-  *form
  ?-  bos
      [1 1]   nif
      [1 0]   bos
      *
    ?-  nif
        [1 1]   bos
        [1 0]   nif
        *       [6 bos [1 0] nif]
    --
  --
::
++  hack
  ~.  %hack
  |=  gen=*gene
  ^-  *<[& p=*gene q=*gene] [| p=*gene]>
  ?-    gen
      [%bnld *]
    ?.  ?=([~ *] p.gen)
      [| gen] 
    =+  pyr=$(gen q.gen)
    ?-    -.pyr
        |   [| [%bnld p.gen p.pyr]]
        &   [& [%bnld p.gen p.pyr] [%bnld p.gen q.pyr]]
    --
  ::
      [%dgdp *]   [& p.gen q.gen]
      [%zpcb *] 
    =+  pyr=$(gen q.gen)
    ?-    -.pyr
        |   [| [%zpcb p.gen p.pyr]]
        &   [& [%zpcb p.gen p.pyr] [%zpcb p.gen q.pyr]]
    --
  ::
      *
    =+  voq=~(open ap gen)
    ?:  .=(gen voq)
      [| gen]
    $(gen voq)
  --
::
++  hike 
  ~.  %hike
  |=  [axe=*axis pac=*(list <[p=*axis q=*form]>)]
  ^-  *form
  ?~  pac
    [0 axe]
  =+  zet=(skim pac.$ |=([p=*axis q=*form] [.=(1 p)]))
  ?~  zet
    =+  tum=(skim pac.$ |=([p=*axis q=*form] ?&(!.=(1 p) .=(2 (cap p)))))
    =+  gam=(skim pac.$ |=([p=*axis q=*form] ?&(!.=(1 p) .=(3 (cap p)))))
    %+  cons
      %=  $
        axe (peg axe 2)
        pac (turn tum |=([p=*axis q=*form] [(mas p) q]))
      --
    %=  $
      axe (peg axe 3)
      pac (turn gam |=([p=*axis q=*form] [(mas p) q]))
    --
  ?>(?=([* ~] zet) q.i.zet)
::
++  look
  ~.  %look
  |=  [cog=*term dab=*(map term foot)]
  =+  axe=`@`1
  |-
  ^-  *(unit <[p=*axis q=*gate]>)
  ?-  dab
      ~         ~
      [* ~ ~]   
    ?:(.=(cog p.n.dab) [~ axe ?>(?=([& *] q.n.dab) p.q.n.dab)] ~)
  ::
      [* ~ *]
    ?:  .=(cog p.n.dab)
      [~ (peg axe 2) ?>(?=([& *] q.n.dab) p.q.n.dab)]
    ?:  (gor cog p.n.dab)
      ~
    $(axe (peg axe 3), dab r.dab)
  ::
      [* * ~]
    ?:  .=(cog p.n.dab)
      [~ (peg axe 2) ?>(?=([& *] q.n.dab) p.q.n.dab)]
    ?:  (gor cog p.n.dab)
      $(axe (peg axe 3), dab l.dab)
    ~
  ::
      [* * *]
    ?:  .=(cog p.n.dab)
      [~ (peg axe 2) ?>(?=([& *] q.n.dab) p.q.n.dab)]
    ?:  (gor cog p.n.dab)
      $(axe (peg axe 6), dab l.dab)
    $(axe (peg axe 7), dab r.dab)
  --
::  
++  ream  
  ~.  %ream 
  |=  txt=@ 
  ^-  *gene 
  ~|('ream-soft' !!)
  :: (rash txt vest)
::  
++  ut
  ~%    %ut
      ->+
    --
      %fan    fan
      %rib    rib
      %vet    vet
      %fab    fab
      %bake   bake
      %burn   burn
      %cull   cull
      %dump   dump
      %emit   emit
      %find   find
      %fire   fire
      %fish   fish
      %fret   fret
      %fuse   fuse
      %gain   gain
      %heal   heal
      %mint   mint
      %nest   nest
      %orth   orth
      %play   play
      %park   park
      %peek   peek
      %repo   repo
      %rest   rest
      %seek   seek
      %snap   snap
      %tuck   tuck
    --
  =+  :*  fan=*(set <[*type *gene]>)
          rib=*(set <[*type *type *gene]>)
          vet=`?`&
          fab=`?`&
      --
  &=  sut=`*type`%noun
  ++  bake
    ~.  %bake
    |=  [dab=*(map term foot)]
    ^-  *<~ ^>
    ?:  ?=(~ dab)
      0
    ?>  ?=(^ dab)
    ?>  ?=([& *] q.n.dab)
    =+  vad=q:(mint(vet ?:(p.p.q.n.dab vet |)) %noun q.p.q.n.dab)
    ?-    dab
        [* ~ ~]   vad
        [* ~ *]   [vad $(dab r.dab)]
        [* * ~]   [vad $(dab l.dab)]
        [* * *]   [vad $(dab l.dab) $(dab r.dab)] 
    --
  ::
  ++  burn
    |-
    ^-  *
    ?-    sut
        %atom       0
        [%cell *]   [$(sut p.sut) $(sut q.sut)]
        [%core *]   ?>(?=(^ p.r.q.sut) [$(sut p.sut) p.r.q.sut])
        [%cube *]   p.sut
        [%face *]   $(sut q.sut)
        [%fork *]   =+([heb=$(sut p.sut) nar=$(sut q.sut)] ?>(.=(heb nar) heb))
        [%hold *]   $(sut repo)
        %noun       ~
        %void       ~|(%burn-void !!)
    --
  ::
  ++  cull
    ~.  %cull
    |=  [axe=*axis ref=*type]
    ^-  *type
    ?:  .=(1 axe)
      (fuse ref)
    =+  [now=(cap axe) lat=(mas axe)]
    |-  ^-  *type
    ?-    sut
        %atom       %void
        [%cell *]   
      ?:  .=(2 now)
        (cell $$(axe lat, sut p.sut) q.sut)
      (cell p.sut $$(axe lat, sut q.sut))
    ::
        [%core *]   ?.(.=(2 now) sut (core $$(axe lat, sut p.sut) q.sut))
        [%cube *]   ?.(.?(p.sut) %void (reco |=(p=*type $$(sut p))))
        [%face *]   (reco |=(p=*type (face p.sut $$(sut p))))
        [%fork *]   (fork $(sut p.sut) $(sut q.sut))
        [%hold *]   (reco |=(p=*type $$(sut p)))
        %noun       (reco |=(p=*type $$(sut p)))
        %void       %void
    --
  ::
  ++  dump
    ^-  *bill
    =+  ^=  gil
        =+  den=[p=`@`1 q=*(map type <@>)]
        =+  vax=*(set type)
        =<  q
        |-  ^-  den
        ?-    sut
            [%cell *]   $(sut q.sut, den $(sut p.sut))
            [%core *]
          ?:  .=(p.sut q.q.sut) 
            $(sut p.sut)
          $(sut p.sut, den $(sut q.q.sut))
        ::
            [%face *]   $(sut q.sut)
            [%fork *]   $(sut q.sut, den $(sut p.sut))
            [%hold *]
          ?:  (~(has in vax) sut)
            ?:  (~(has by q.den) sut)
              den
            [.+(p.den) (~(put by q.den) [sut p.den])]
          $(vax (~(put in vax) sut), sut repo)
        ::
            *           den
        --
    =+  gax=*(set type)
    |-
    ?-    sut
        %atom       '@'
        %noun       '*'
        %void       '#'
    ::
        [%cell *]
      :+  %grip
        ['[' ']']
      :-  $(sut p.sut)
      |-
      ?.  ?=([%cell *] q.sut)
        [$$(sut q.sut) ~]
      [$$(sut p.q.sut) $(q.sut q.q.sut)]
    ::
        [%core *]
      =+  gep=?:(?=([[%% [& *]] ~ ~] q.r.q.sut) '|' '&')
      =+  ^=  nox
          ^-  @
          ?-(p.q.sut %gold '.', %iron '=', %lead ':', %wood '*')
      =+  wil=?:(.=(p.sut q.q.sut) nox (cat 3 nox nox))
      =+  viq=(cat 3 gep wil)
      :^    %grip
          [(cat 3 viq '{') '}']
        $(sut p.sut)
      ?:(.=(p.sut q.q.sut) ~ [$(sut q.q.sut) ~])
    ::
        [%cube *]   ?:(.=(0 p.sut) '~' ~(gut go p.sut))
        [%face *]   [%meld ~(tem go p.sut) '=' $(sut q.sut) ~]
    ::
        [%fork *]
      ?:  .=([%fork [%cube 0] [%cube 1]] sut)
        '?'
      :+  %grip
        ['<' '>']
      :-  $(sut p.sut)
      |-
      ?.  ?=([%fork *] q.sut)
        [$$(sut q.sut) ~]
      [$$(sut p.q.sut) $(q.sut q.q.sut)]
    ::
        [%hold *]
      =+  piv=(~(get by gil) sut)
      ?~  piv
        $(sut repo)
      :*  %meld
          '$'
          ~(dem go u.piv)
          ~
          ?:  (~(has in gax) sut)
            ~
          [':' $(gax (~(put in gax) sut), sut repo) ~]
      --
    --
  ::
  ++  emit
    ~.  %emit
    |=  :*  axe=*axis 
            men=*(list <[p=*type q=*gate]>)
            har=*(list <[p=*gene q=*gene]>)
        --
    =+  luf=*(list <[p=*axis q=*form]>)
    |-  ^-  [p=*(list <[p=*type q=*gate]>) q=*form]
    ?~  har
      [men (hike axe luf)]
    =+  peh=(flop ~(rake ap p.i.har))
    =-  $(har t.har, men q.zos, luf [(need p.zos) luf])
    ^=  zos
    |-  ^-  [p=*(unit <[p=*axis q=*form]>) q=*(list <[p=*type q=*gate]>)]
    ?~  men
      [~ ~] 
    =+  lax=$(men t.men)
    =+  taq=(tuck(sut p.i.men) peh sut q.i.har)
    :-  ~|('emit-mate' (mate p.lax `p.lax`[~ u=q.taq]))
    [[p.taq q.i.men] q.lax]
  ::
  ++  find
    ~.  %find
    |=  [way=*<%read %rite> cog=*term]
    =-  ?~  hoq
          ~~  ~(tem go `@`cog)
          ~~  dump
          ~|(%find-fail !!)
        u.hoq
    ^=  hoq
    =+  gil=*(set type)
    |-
    ^-  *(unit port)
    ?-    sut
    ::
        [%cell *]
      =+  taf=$(sut p.sut)
      ?~  taf
        =+  bov=$(sut q.sut)
        ?~  bov
          ~
        [~ (peg 3 p.u.bov) q.u.bov]
      [~ (peg 2 p.u.taf) q.u.taf]
    ::
        [%core *]
      =+  zem=(look cog q.r.q.sut)
      ?~  zem
        =+  taf=$(sut p.sut)
        ?~  taf
          ~
        ?.  (park way p.u.taf)
          ::  ~|  [%port |.((~(fly to ~(tem go `@`cog)) 75))]
          ::  ~|  [%type |.((~(fly to dump) 75))]
          ::  ~|  [%way |.((~(fly to ~(tem go `@`way)) 75))]
          ::  ~|  [%axe |.((~(fly to ~(dem go `@`p.u.taf)) 75))]
          ~|(%find-park !!)
        [~ (peg 2 p.u.taf) q.u.taf]
      [~ 1 | (peg 3 p.u.zem) [[sut q.u.zem] ~]]
    ::
        [%face *]
      ?:  .=(cog p.sut)
        [~ 1 & q.sut]
      ~
    ::
        [%fork *]
      =+  hax=$(sut p.sut)
      =+  yor=$(sut q.sut)
      ?~  hax
        ?~  yor
          ~
        ::  ~|  [%port |.((~(fly to ~(tem go `@`cog)) 75))]
        ::  ~|  [%type |.((~(fly to dump) 75))]
        ~|(%find-fork !!)
      ?~  yor
        ::  ~|  [%port |.((~(fly to ~(tem go `@`cog)) 75))]
        ::  ~|  [%type |.((~(fly to dump) 75))]
        ~|(%find-fork !!)
      ?:  .=(hax yor)
        hax
      ?.  .=(p.u.hax p.u.yor)
        ~|(%find-fork !!)
      ?-    -.q.u.hax
          &
        ?-    -.q.u.yor
            &  [~ p.u.hax [& (fork p.q.u.hax p.q.u.yor)]]
            |  ~|(%find-fork !!)
        --
      ::
          |
        ?-    -.q.u.yor
            &  ~|(%find-fork !!)
            |
          ?.  .=(p.q.u.yor p.q.u.hax)
            ~|(%find-fork !!)
          [~ p.u.hax | p.q.u.hax (weld q.q.u.hax q.q.u.yor)]
        --
      --
    ::
        [%hold *]
      ?:  (~(has in gil) sut)
        ~
      $(gil (~(put in gil) sut), sut repo)
    ::
        *           ~
    --
  ::
  ++  fire
    ~.  %fire
    |=  hag=*(list <[p=*type q=*gate]>)
    ^-  *type
    :-  %hold
    %+  turn
      hag
    |=  [p=*type q=*gate]
    ?>  ?=([%core *] p)
    =+  dox=[%core q.q.p q.p]
    ?:  p.q
      ?.  ?|(!vet (nest(sut q.q.p) p.p))
        ::  ~~  dump(sut q.q.p)   ::  need
        ::  ~~  dump(sut p.p)     ::  have
        ~|('fire-dry' !!)
      [dox q.q]
    ?.  ?|(!vet .=(p.p q.q.p) (fret(sut p) dox q.q))
      ::  ~~  ~(gut go `*`q:(mint(sut dox, vet |, fab &) %noun q.q))
      ::  ~~  ~(gut go `*`q:(mint(sut p, fab &) %noun q.q))
      ~~  dump(sut p)
      ~~  dump(sut dox)
      ~|('fire-wet' !!)
    [p q.q]
  ::
  ++  fish
    ~.  %fish
    |=  axe=*axis
    =+  vit=*(set type)
    |-
    ^-  *form
    ?-  sut
        %atom       (flip [3 0 axe])
        %void       [1 1]
        %noun       [1 0]
    ::
        [%cell *]
      %+  flan
        [3 0 axe]
      (flan $(sut p.sut, axe (peg axe 2)) $(sut q.sut, axe (peg axe 3)))
    ::
        [%core *]   [0 0]
        [%cube *]   [5 [1 p.sut] [0 axe]]
        [%face *]   $(sut q.sut)
        [%fork *]   (flor $(sut p.sut) $(sut q.sut))
        [%hold *]
      ?:  (~(has in vit) sut)
        ::  ~|  [%type |.((~(fly to dump) 75))]
        ::  ~|  [%axis |.((~(fly to ~(gut go `*`axe)) 75))]
        ~|(%fish-loop !!)
      =>  %=(. vit (~(put in vit) sut))
      $(sut repo)
    --
  ::
  ++  fret
    ~.  %fret
    |=  [dox=*type gen=*gene]
    ^-  ?
    ?|  (~(has in rib) [sut dox gen])
        .=  q:(mint(fab &, sut dox, vet |) %noun gen)
          q:(mint(fab &, rib (~(put in rib) [sut dox gen])) %noun gen)
    --
  ::
  ++  fuse
    ~.  %fuse
    |=  ref=*type
    =+  bix=*(set <[*type *type]>)
    |-  ^-  *type
    ?:  .=(sut ref)
      sut
    ?-    sut
        %atom 
      ?-    ref
          [%cell *]   %void
          *           $(sut ref, ref sut)
      --
    ::
        [%cell *]   
      ?-    ref
          [%cell *]   (cell $(sut p.sut, ref p.ref) $(sut q.sut, ref q.ref))
          *           $(sut ref, ref sut)
      --
    ::
        [%core *]   $(sut repo)
        [%cube *]
      ?-    ref
          %atom       ?:(.?(p.sut) %void sut)
          [%cell *]   ?:(.?(p.sut) $(sut repo) %void)
          [%cube *]   %void
          *           $(sut ref, ref sut)
      --
    ::
        [%face *]     (face p.sut $(sut q.sut))
        [%fork *]     (fork $(sut p.sut) $(sut q.sut))
        [%hold *]
      ?:  (~(has in bix) [sut ref])
        ::  ~|  [%fuse-sut |.((~(fly to dump) 75))]
        ::  ~|  [%fuse-ref |.((~(fly to dump(sut ref)) 75))]
        ~|(%fuse-loop !!)
      $(bix (~(put in bix) [sut ref]), sut repo)
    ::
        %noun       ref
        %void       %void
    --
  ::
  ++  gain
    ~.  %gain
    |=  [gen=*gene]
    ^-  *type
    =-  ?:((orth(sut %noun) fiz) %void fiz)   ::  ?? - do we need this?
    ^=  fiz
    ?-    gen
        [%csbn *]   (cull p:(seek %read ~(rake ap q.gen)) (play p.gen))
        [%cspm *]   |-(?~(p.gen sut $(p.gen t.p.gen, sut $$(gen i.p.gen))))
        [%zpcb *]   $(gen q.gen)
        [%zpdx *]   $(gen p.gen)
        *           sut
    --
  ::
  ++  heal
    ~.  %heal
    |=  [qog=*(unit term) axe=*axis ref=*type]
    ^-  *type
    ?:  .=(1 axe)
      ?~  qog
        ref
      |-  ^-  *type
      ?-    sut
          [%core *]   ref
          [%face *]   (face p.sut ref)
          [%fork *]   (fork $(sut p.sut) $(sut q.sut))
          *           $(sut repo)
      --
    =+  [now=(cap axe) lat=(mas axe)]
    |-  ^-  *type
    ?-    sut
        %atom       %void
        [%cell *]
      ?:  .=(2 now)
        (cell $$(sut p.sut, axe lat) q.sut)
      (cell p.sut $$(sut q.sut, axe lat))
    ::
        [%core *]   ?>(.=(2 now) (core $$(sut p.sut, axe lat) q.sut))
        [%fork *]   (fork $(sut p.sut) $(sut q.sut))
        *           $(sut repo)
    --
  ::
  ++  mint
    ~.  %mint
    |=  [gol=*type gen=*gene]
    ^-  [p=*type q=*form]
    =<  $
    &.
    ::  ++  boil  |=(rey=|.(*form) ?.(fab [0 0] $.rey))
    ++  coke
      |=  [nug=*form]
      ?-    nug
          [0 *]   p.nug
          [10 *]  $(nug q.nug)
          *       ~|(%mint-coke !!)
      --
    ::
    ++  crow
      |=  [mel=*<%gold %lead %iron> ruf=*gene dab=*(map term foot)]
      ^-  [p=*type q=*form]
      =+  dan=$$(gen ruf, gol %noun)
      ?.  fab
        [(core p.dan mel p.dan [[0 0] dab]) [0 0]]
      =+  toc=(core p.dan [%gold p.dan [~ dab]])
      =+  dez=(bake(sut toc) dab)
      :*  (nice (core p.dan mel p.dan [dez dab]))
          (cons q.dan [1 dez])
      --
    ::
    ++  nice
      |=  typ=*type
      ?.  ?|(!vet (nest(sut gol) typ))
        ~~  dump(sut gol)
        ~~  dump(sut typ)
        ~|('mint-nice' !!)
      typ
    ::
    ++  $
      ^-  [p=*type q=*form]
      ?-    gen
          [%bnld *]                                                   ::  =>
        =+  fid=$(gen p.gen, gol %noun)
        =+  soq=$(sut p.fid, gen q.gen)
        [p.soq (comb q.fid q.soq)]
      ::
          [%csbn *]                                                   ::  ?=
        :-  (nice flag)
        ?.  fab
          [0 0]
        (fish(sut (play p.gen)) (coke q:$(gen q.gen, gol %noun)))
      ::
          [%csdg *]                                                   ::  ?:
        =+  nor=$(gen p.gen, gol flag)
        =+  fex=(gain p.gen)
        =+  hiq=$(sut ?:(.=(%void fex) sut fex), gen q.gen)
        =+  ran=$(gen r.gen)
        [(fork p.hiq p.ran) [6 q.nor q.hiq q.ran]]
      ::
          [%dgdp *]                                                   ::  :-
        =+  hed=$(gen p.gen, gol %noun)
        =+  tal=$(gen q.gen, gol %noun)
        [(nice (cell p.hed p.tal)) (cons q.hed q.tal)]
      ::
          [%dtbn *]                                                   ::  .=
        :-  (nice flag)
        [5 q:$(gen p.gen, gol %noun) q:$(gen q.gen, gol %noun)]
      ::
          [%dtcs *]                                                   ::  .?
        :-  (nice flag)
        [3 q:$(gen p.gen, gol %noun)]
      ::
          [%dtpd *]                                                   ::  .+
        :-  (nice %atom)
        [4 q:$(gen p.gen, gol %atom)]
      ::
          [%dtsg *]                                                   ::  .~ 
        :-  (nice [%cube p.gen])
        [1 p.gen]
      ::
          [%dttr *]                                                   ::  .*
        :-  (nice %noun)
        [2 q:$(gen p.gen, gol %noun) q:$(gen q.gen, gol %noun)]
      ::
          [%ktbn *]                                                   ::  ^=
        =+  vat=$(gen q.gen)
        [(face p.gen p.vat) q.vat]
      ::
          [%ktdp *]                                                   ::  ^-
        =+  hif=(nice (play p.gen))
        [hif ?.(fab [0 0] q:$(gen q.gen, gol hif))]
      ::
          [%ktpd *]                                                   ::  ^+
        =+  zut=(play p.gen)
        ?.  ?|(!vet (nest(sut gol) zut))
          ~|(%mint-cool !!)
        $(gen q.gen, gol zut)
      ::
          [%ktsg *]                                                   ::  ^~
        =+  cag=burn  
        =+  nef=$(gen p.gen)
        [p.nef [1 ~|(%ketsig-nock .*(cag q.nef))]]
      ::
          [%mtbn *]                                                   ::  %=
        =+  lar=(seek %read p.gen)
        ?-    -.q.lar
            & 
          =+  fup=(emit p.lar [[p.q.lar [& ~ 1]] ~] q.gen)
          [(nice -<.p.fup) q.fup]
        ::
            |
          =+  fup=(emit p.lar q.q.lar q.gen)
          [(nice (fire p.fup)) [9 p.q.lar q.fup]]
        --
      ::
          [%pmdg *]                                                   ::  &:
        (crow %lead [%dgdp p.gen [~ 1]] q.gen)
      ::
          [%pmdt *]                                                   ::  &.
        (crow %gold [~ 1] p.gen)
      ::
          [%pmpd *]                                                   ::  &+
        (crow %iron [%dgdp p.gen [~ 1]] q.gen)
      ::
          [%sgld *]                                                   ::  ~>
        =+  hum=$(gen q.gen)
        :-  p.hum
        :+  10
          ?-    p.gen
              @   p.gen
              ^   [p.p.gen q:$(gen q.p.gen, gol %noun)]
          --
        q.hum
      ::
          [%zpbn *]                                                   ::  !=
        :-  (nice %noun)
        [1 q:$(vet |, gen p.gen)]
      ::
          [%zpcb *]                                                   ::  !_
        ~~  ~(loc go p.gen)
        ::  ~|  [%spot |.((~(fly to ~(loc go p.gen)) 75))]
        =+  hum=$(gen q.gen)
        [p.hum [10 [%spot 1 p.gen] q.hum]]
      ::
          [%zpdx *]                                                   ::  !#
        ~#
        $(gen p.gen)
      ::
          [%zpzp ~]                                                   ::  !!
        :-  %void
        [0 0]
      ::
          *           
        =+  doz=~(open ap gen) 
        ?:  .=(doz gen)
          ::  ~|  [%open-gene |.((~(fly to ~(gut go `*`gen)) 75))]
          ~|(%mint-open !!)
        $(gen doz)
      --
    ==
  ::
  ++  nest
    ~.  %nest
    |=  ref=*type
    ^-  ?
    =+  gil=*(set <[p=*type q=*type]>)
    =<  dext
    &.
    ++  cong
      ^-  ?
      ?>  ?&(?=([%core *] sut) ?=([%core *] ref))   :: XX use wood
      ?:  .=(q.sut q.ref)
        dext(sut p.sut, ref p.ref)
      ?.  ?&  dext(sut q.q.sut, ref p.sut)
              dext(sut p.sut, ref q.q.sut) 
              dext(sut q.q.ref, ref p.ref) 
          --
        |
      ?:  .=(%wood p.q.sut)
        ?&(.=(%wood p.q.ref) .=(q.r.q.sut q.r.q.ref))
      ?&
        ?|(.=(p.q.sut p.q.ref) .=(%gold p.q.ref))
        (cram(sut sut(p q.q.sut), ref ref(p q.q.ref)) q.r.q.sut q.r.q.ref)
        ?-    p.q.sut
            %gold
          =+  pac=[s=q.q.sut r=q.q.ref]
          ?&  dext(sut s.pac, ref r.pac)
              dext(sut r.pac, ref s.pac)
          --
        ::
            %iron
          =+  sam=[s=(peek(sut q.q.sut) %rite 2) r=(peek(sut q.q.ref) %rite 2)]
          dext(sut r.sam, ref s.sam)
        ::
            %lead
          =+  pal=[s=(peek(sut q.q.sut) %read 2) r=(peek(sut q.q.ref) %read 2)]
          dext(sut s.pal, ref r.pal)
        --
      --
    ::
    ++  cram
      |=  [dab=*(map term foot) hem=*(map term foot)]
      ^-  ?
      ?-    dab
          ~   .=(hem ~)
          ^
        ?&  ?=(^ hem) 
            .=(p.n.dab p.n.hem)
            $(dab l.dab, hem l.hem)
            $(dab r.dab, hem r.hem)
            ?-    q.n.dab
                [& *]
              ?&  ?=([& *] q.n.hem) 
                  ?&(p.p.q.n.dab p.p.q.n.hem)
                  dext(sut (play q.p.q.n.dab), ref (play(sut ref) q.p.q.n.hem))
              --
            ::
                [| *]
              ?|  .=(~ p.q.n.dab)
                  ?&(?=([| *] q.n.hem) $(dab p.q.n.dab, hem p.q.n.hem))
              --
            --
        --
      --
    ::
    ++  dext
      ^-  ?
      ?:  .=(sut ref)
        &
      ?-  sut
          %atom       ?-(ref %atom &, [%cube *] !.?(p.ref), * sint)
          %void       sint
          %noun       &
      ::
          [%cell *]
        ?.  ?=([%cell *] ref)
          sint
        ?&
          dext(sut p.sut, ref p.ref)
          dext(sut q.sut, ref q.ref)
        --
      ::
          [%core *]   
        ?.  ?=([%core *] ref) 
          sint
        cong
      ::
          [%cube *]   ?.(?=([%cube *] ref) sint .=(sut ref))
          [%face *]   dext(sut q.sut)
          [%fork *]
        ?.  ?=(*<%atom %noun [%cell *] [%cube *] [%core *]> ref)
          sint
        ?|(dext(sut p.sut) dext(sut q.sut))
      ::
          [%hold *]
        ?|
          (~(has in gil) [sut ref])
          dext(gil (~(put in gil) [sut ref]), sut repo)
        --
      --
    ::
    ++  sint
      ^-  ?
      ?-  ref
          %atom       |
          [%cell *]   |
          [%fork *]   ?&(dext(ref p.ref) dext(ref q.ref))
          [%hold *]
        ?|
          (~(has in gil) [sut ref])
          dext(gil (~(put in gil) [sut ref]), ref repo(sut ref))
        --
      ::
          %noun       |
          %void       &
          *           dext(ref repo(sut ref))
      --
    ==
  ::
  ++  orth
    ~.  %orth
    |=  ref=*type
    ^-  ?
    =+  bix=*(set <[*type *type]>)
    |-
    ?-    sut
        %atom       ?-(ref %atom |, [%cell *] &, * $(sut ref, ref sut))
        [%cell *]
      ?:  ?=([%cell *] ref)
        ?|($(sut p.sut, ref p.ref) $(sut q.sut, ref q.ref))
      $(sut ref, ref sut)
    ::
        [%core *]   $(sut [%cell p.sut %noun])
        [%cube *]
      ?-  ref
          %atom       .?(p.sut)
          [%cell *]   ?|  !.?(p.sut)
                          $(sut [%cell [%cube -.p.sut ] [%cube +.p.sut]])
                      --
          [%cube *]   !.=(p.sut p.ref)
          *           $(sut ref, ref sut)
      --
    ::
        [%face *]   $(sut q.sut)
        [%fork *]   ?&($(sut p.sut) $(sut q.sut))
        [%hold *]
      ?|
        (~(has in bix) [ref sut])
        $(bix (~(put in bix) [ref sut]), sut repo)
      --
    ::
        %noun       (nest(sut %void) ref)
        %void       &
    --
  ::
  ++  park
    ~.  %park
    |=  [way=*<%read %rite> axe=*axis]
    ^-  ?
    ?>  ?=([%core *] sut)
    ?|  
      !vet
      ?-    way
          %read
        ?-    p.q.sut
            %gold   &
            %iron   | 
            %lead   .=(2 (cap axe))
            %wood   &
        --
      ::
          %rite
        ?-    p.q.sut
            %gold   &
            %iron   .=(2 (cap axe))
            %lead   | 
            %wood   &
        --
      --
    --
  ::
  ++  peek
    ~.  %peek
    |=  [way=*<%read %rite> axe=*axis]
    ^-  *type
    ?:  .=(1 axe)
      sut
    =+  [now=(cap axe) lat=(mas axe)]
    ?-    sut
        %atom       %void
        %void       %void
        %noun       %noun
        [%cell *]   ?:(.=(2 now) $(sut p.sut, axe lat) $(sut q.sut, axe lat))
        [%core *]   
      ?:  .=(2 now) 
        ?.  (park way lat)
          ::  ~|  [%axis |.((~(fly to ~(dem go `@`axe)) 75))]
          ::  ~|  [%type |.((~(fly to dump) 75))]
          ~|(%peek-park !!)
        $(sut p.sut, axe lat) 
      %noun
    ::
        [%cube *]   
      ?.  .?(p.sut) 
        %void 
      ?:  .=(2 now) 
        $(sut [%cube -.p.sut], axe lat)
      $(sut [%cube +.p.sut], axe lat)
    ::
        [%face *]   $(sut q.sut)
        [%fork *]   (fork $(sut p.sut) $(sut q.sut))
        [%hold *]   $(sut repo)
    --
  ::
  ++  play
    ~.  %play
    |=  gen=*gene
    ^-  *type
    p:(mint(vet |, fab |) %noun gen)
  ::
  ++  reco
    |*  fud=|=(p=*type p)
    =+  por=repo
    =+  yot=(fud por)
    ?:  .=(yot por)
      sut
    yot
  ::
  ++  repo
    ^-  *type
    ?-    sut
        [%cube *]   ?.(.?(p.sut) %atom [%cell [%cube -.p.sut] [%cube +.p.sut]])
        [%core *]   [%cell p.sut %noun]
        [%face *]   q.sut
        [%hold *]   (rest p.sut)
        %noun       [%fork %atom [%cell %noun %noun]]
    --
  ::
  ++  rest
    ~.  %rest
    |=  leg=*(list <[p=*type q=*gene]>)   ::  XX use +-
    ^-  *type
    ?:  (lien leg |=([p=*type q=*gene] (~(has in fan) [p q])))
      ~|(%rest-loop !!)
    =>  .(fan (~(gas in fan) leg))
    %+  roll
      %-  %~  tap 
            in 
          %-  ~(gas in *(set type))
          (turn leg |=([p=*type q=*gene] (play(sut p) q)))
      ~
    =+([p=*type q=`*type`%void] |.((fork p q)))
  ::
  ++  seek
    ~.  %seek
    |=  [way=*<%read %rite> hep=*twig]
    ^-  *port
    ?~  hep
      [1 & sut]
    =+  zar=$(hep t.hep)
    =+  ^=  syp
        ?-    -.q.zar
            &  p.q.zar
            |  (fire (turn q.q.zar |=([p=*type q=*gate] [p [& ~ 1]])))
        --
    ?-    i.hep
        @
      =+  hud=(find(sut syp) way i.hep)
      [(peg p.zar p.hud) q.hud]
    ::
        [~ *]
      [(peg p.zar p.i.hep) & (peek(sut syp) way p.i.hep)]
    --
  ::
  ++  snap
    ~.  %snap
    |=  gen=*gene
    ^-  *gene 
    ?-    sut
        [%cell *]
      =+  haq=(hack gen)
      ?-  -.haq
        &   [%dgdp $(sut p.sut, gen p.haq) $(sut q.sut, gen q.haq)]
        |   p.haq
      --
    ::
        [%face *]   [%ktbn p.sut $(sut q.sut)]
        [%hold *]   $(sut repo)
        *           gen
    --
  ::
  ++  tuck
    ~.  %tuck
    |=  [peh=*twig boz=*type rix=*gene]
    =+  axe=`@`1
    |-
    ^-  [p=*type q=[p=*axis q=*form]]
    ?~  peh
      =+  lof=(mint(sut boz) %noun rix)
      [p.lof [axe q.lof]]
    ?-    i.peh
        @
      =+  wer=(find %rite i.peh)
      ?.  ?=(& -.q.wer)
        ~|('tuck-gate' !!) 
      =+  giv=$(sut p.q.wer, axe (peg axe p.wer), peh t.peh)
      [(heal [~ i.peh] p.wer p.giv) q.giv]
    ::
        [~ *]
      =+  vas=(peek %rite p.i.peh)
      =+  ^=  giv
          %=    $
              sut   vas
              rix   ?~(t.peh (snap(sut vas) rix) rix)
              axe   (peg axe p.i.peh)
              peh   t.peh
          --
      [(heal ~ p.i.peh p.giv) q.giv]
    --
  ==
::
++  vest
  !!
==

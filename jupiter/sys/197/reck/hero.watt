!:
::          %hero, an http server.   This file is in the public domain.
::
:-  %hero
^-  dock
|=  [now=time wha=@ta]
%^    hull
    (iris now)
  wha
^-  bead
|=  [now=time wha=@ta]
:-  ^-  lime
    :^    %rod
        %abel
      :-  [~ ~]
      :-  [%hose %line ~]
      |=  hap=*  ^-  (unit)
      ?.  ?=([p=@ta q=@ta ~] hap)
        ~
      =+  zod=[p=(colt p.hap) q=(colt q.hap)]
      ?.  ?&(?=(^ p.zod) ?=(^ q.zod))
        ~
      [~ u.p.zod u.q.zod]
    ^-  hunt
    |=  [seq=@ud muz=* cax=bill]
    ?>  ?=(tube muz)
    [%run %line muz q.cax]
^-  bowl
=>  ..$
=<  |%
    ++  peek  |=([cam=lens hap=path] ~)
    ++  poke  
      |=  [cam=lens man=*] 
      ^-  [p=lime q=bowl]
      =+  muv=(move man)
      ?.  =(muv man)
        [~ ..poke] 
      =+  guo=(line p.muv q.muv cam)
      [p.guo ..poke(..line q.guo)]
    --
=>  |%
    ++  desk                            ::  server, per post
      $:  who=@p                        ::  server identity
          use=(map ,@ta user)           ::  users
      ==
    ++  user
      $:  who=@p                        ::  64-bit user
          liv=(map tube talk)
      ==

    ++  talk 
      nub=vase                      ::  system + libraries
          red=vase                      ::  result log
          ser=vase                      ::  source log
          way=(map ,@ta vase)           ::  environment variables 
      ==
    ++  game  
      $:  ipo=?                         ::  0 or insecure port (8.080)
          spo=?                         ::  0 or secure port (8.443)
          sev=(map ,@p desk)            ::  servers
      ==
           
    (map tube desk)           ::  application state
    ++  move                            ::  shell command
      $%  [%line p=tube q=@ta]          ::  line input
      ==
    --
=+  sys=*game
|%
++  lean                                    ::  apply line result
  |=  [txt=@t pet=@ta dub=tube tuy=desk]
  |=  ten=tune
  ^-  [p=lime q=_..lean]
  ?-    ten
      [0 *]
    ?+    pet  [[%say %yo %p dub 0 [%leaf "<unknown command>"]] ..lean]
        %%
      =+  ham=~(dole ut p.p.ten)
      :-  [%say %yo %p dub 0 (dish:ut ham q.p.ten)]
      %=  ..lean
        sys  %+  ~(put by sys) 
               dub
             %=  tuy
               red  (slop p.ten red.tuy)
               ser  (slop [[%atom %t] txt] ser.tuy)
             ==
      ==
    ::
        %set
      ?.  ?=([%face *] p.p.ten)
        [[%say %yo %p dub 0 [%leaf "<usage: \":set name=value\">"]] ..lean]
      :-  ~
      %=  ..lean
        sys  %+  ~(put by sys) 
               dub
             tuy(way (~(put by way.tuy) p.p.p.ten [q.p.p.ten q.p.ten]))
      ==
    ::
        %type
      [[%say %yo %p dub 0 (dial:ut ~(dole ut p.p.ten))] ..lean]
    ==
  ::
      [1 *]
    :-  :-  %all
        %+  turn  p.ten
        |=  mis=*
        =+  vad=(dish:ut [[~ %path] (path mis)])
        [%say %yo %p dub 0 [%leaf "[need {~(ram re vad)}]"]]
    ..lean
  ::
      [2 *]
    [[%say %yo %t p.ten] ..lean]
  ==
::
++  lick                                    ::  synthetic namespace
  |=  cam=lens
  |=  nam=*
  ^-  (unit)
  =+  pax=(path nam)
  =+  voy=(peek:cam [%cary pax])
  voy
:: 
++  line                                    ::  execute a line
  |=  [dub=tube txt=@t cam=lens]
  ^-  [p=lime q=_..line]
  =+  ^=  fob  ^-  [p=term q=gene]
      %+  rash
        txt
      ;~  pose 
        (stag %% wide:vast)
        ;~  plug
          ;~(pfix col sym)
          ;~(pfix ace wide:vast)
        ==
      ==
  =+  xac=(~(get by sys) dub)
  =+  ^=  tuy  ^-  desk
      ?:  ?=(^ xac)
        u.xac
      [!>(..zuul) [[%cube 0 %atom %n] ~] [[%cube 0 %atom %n] ~] ~]
  %-  (lean txt p.fob dub tuy)
  (slab =(%type p.fob) [(lube [when:cam tuy]) q.fob] (lick cam))
::
++  lube                                    ::  construct context
  |=  [now=@da tuy=desk]  ^-  vase
  =+  yad=~(rent co [~ %da now])
  ::  ~&  [%what `@ud`now yad]
  %+  slop
    [[%atom %ta] ~(rent co [~ %da now])]
  %+  slop
    %+  slop
      [[%face %$ p.ser.tuy] q.ser.tuy]
    [[%face %$ p.red.tuy] q.red.tuy]
  (slum nub.tuy way.tuy)
--
